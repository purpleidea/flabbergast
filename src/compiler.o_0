# The parser for Flabbergast is constructed by assembly of small parser
# combinators that are rendered into a parser in the target language. This
# describes the interface expected.
parser_tmpl : Template {
	# Parses nothing, always succeeds.
	nop : Template {}
	# Only succeeds if the compiler allows extensions (`X` syntax)
	allow_extensions : Template {}
	# Match a literal string, exactly as provided.
	exact : Template { word : Required }
	# Match another parse element, but, if parsing fails, back up the parser and
	# continue to the next rule.
	optional : Template { of : Required }
	# Match a list of parse elements, in order.
	sequence : Template { of : Required }
	# Match a parse element many times, with the provided separator in between
	# each element. That is, parse a list of the form `e,e,e` where `e` is the
	# element and `s` is the separator. The `nonempty` Boolean insists that there
	# is at least one element parsed, otherwise, an empty is list is valid.
	many : Template { of : Required  separator : Null  nonempty : False }
	many_word : Template many {
		separator_word : Required
		separator : exact { word : separator_word }
	}
	# Parses the elements provided in succession, succeeding if any one succeeds
	# and failing if all fail.
	alternate : Template { of : Required }
	# Parses a single character in the range of characters provided.
	range : Template { from : Required  to : Required }
	# Parses a single character, as indicated.
	single : Template {
		# A string of characters where the parser may match any single character in
		# the string.
		char : Required
		# If true, parsing will succeed if the current character is not in the
		# string defined in `char`.
		invert_match : False
		# If the end of input is encoutered, should that be a match or a mismatch?
		match_eof : False
	}
	# Matches any character by Unicode class.
	char_class : Template {
		# A list of character classes to match
		classes : Required
		# If true, parsing will succeed if the current character is not in the
		# any of the character classes enabled.
		invert_match : False

		letter_lower : Used
		letter_modifier : Used
		letter_other : Used
		letter_title : Used
		letter_upper : Used
		mark_combining : Used
		mark_enclosing : Used
		mark_nonspace : Used
		number_decimal : Used
		number_letter : Used
		number_other : Used
		other_control : Used
		other_format : Used
		other_private : Used
		other_surrogate : Used
		other_unassigned : Used
		punctuation_connector : Used
		punctuation_dash : Used
		punctuation_end : Used
		punctuation_final_quote : Used
		punctuation_initial_quote : Used
		punctuation_other : Used
		punctuation_start : Used
		separator_line : Used
		separator_paragraph : Used
		separator_space : Used
		symbol_currency : Used
		symbol_math : Used
		symbol_modifier : Used
		symbol_other : Used
	}
	# Checks that the next character is not one of the specified characters, but does not consume it.
	except : Template {
		# A string with characters to match
		char : Required
	}
	# Parses sub rules and uses their values to compute an integer.
	accumulate_integer : Template {
		# Each successful rule where `accumulate` is true will have the current
		# input character applied to the accumulator.
		accumulate : False
		# The initial value of the accumulator.
		initial : 0
		# The multiplier is the base of the number used. At each character, the
		# existing value will be multiplied by the supplied multiplier before the
		# new value is added.
		multiplier : Used
		# The character will have the provided offset subtracted from the current
		# character before adding it to the accumulator.
		offset : Used
		# After successful parsing, the value is stored in the desired field.
		field : Required
		in : Required
	}
	# This works much like `accumulate_integer` except the integer is a Unicode
	# codepoint added to the currently accumulated string.
	accumulate_unichar_integer : Template {
		# Each successful rule where `accumulate` is true will have the current
		# input character applied to the accumulator.
		accumulate : False
		# The initial value of the accumulator.
		initial : 0
		# The multiplier is the base of the number used. At each character, the
		# existing value will be multiplied by the supplied multiplier before the
		# new value is added.
		multiplier : Used
		# The character will have the provided offset subtracted from the current
		# character before adding it to the accumulator.
		offset : Used
		in : Required
	}
	accumulate_float : Template { accumulate : False  field : Required  in : Required }
	accumulate_list : Template {
		accumulate : False
		field : Required
		item_type : Required
		in : Required
		# Remove duplicates using the field name provided. It must be common to
		# all the children.
		deduplicate : Null
		# Field values which are not permitted at all.
		forbid : []
	}
	accumulate_string : Template { accumulate : False  field : Required  in : Required }
	# Adds a Unicode literal, by codepoint, to the currently accumulating string
	# after successfully parsing the child parse expression.
	collect_codepoint : Template { codepoint : Required  in : Required }
	# Parses another rule
	other : Template {
		# This it the name (and therefore type) of the desired rule to parse.
		item_type : Required
		# Some rules have many possible AST nodes that they can generate. In some
		# instances, it is desirable to parse only subsets of those possible AST
		# nodes. Rules may then define groups of AST nodes as “alternate” versions
		# of the rule, which will produce the same type, but a different possible
		# subset of values. If specified, this selects one of the predefined
		# subsets. The name of any given AST node is also valid.
		alternate : Null
		# The field in which to place the result. If `Null`, it will be added to
		# the current list.
		field : Required
	}
}
# Environments are domains in which lookups always yield the same value. They
# are used to break generated code into chunks where lookups occur only in the
# boundaries between chunks. Each syntax element inherits an environment from
# the containing element and then applies it to its children, if any.
#
# Different parts of the code have different semantics, so there are different
# flavours of environment application.
environment_tmpl : Template {
	# A template for all the actions (i.e., things which can be done with an
	# environment).
	application_action : Template { }
	# Collect the current environment and provide it to any containing
	# `other_with_result` rules.
	collect : Template application_action {}
	document : Template application_action {
		documentation_field : Null
	}
	# Apply environment to other syntax elements that support environments.
	other_elements : Template application_action {
		# A list of fields to absorb the current environment
		fields : Required
	}
	# Apply environment to other syntax elements and collect the environment and
	# apply to to others.
	other_with_result : Template application_action {
		# The field containing the target environment to be collected.
		field : Required
		# The name of this environment for later retrieval.
		name : Required
		apply_to : Required
	}
	# Apply environment to all the other syntax elements in a list.
	list_of : Template application_action {
		# The field containing the list.
		field : Required
	}
	# Apply an *independent* environment for each of the other syntax elements in
	# a list.
	list_independent : Template application_action {
		# The field containing the list of elements.
		field : Required
		# Whether to start with a blank environment or derive from the current environment.
		inherit : False
		# Whether the environment is file-level scope.
		top_level : False
	}
	# Create an empty environment that does not inherit from the current environment.
	blank_environment : Template application_action {
		# A list of actions to perform using this new environment.
		apply_to : Required
		# A name to store the environment for later use during code generation.
		name : Required
	}
	modified_environment : Template application_action {
		# A list of actions to perform using this new environment.
		apply_to : Required
		# If true, unmasked lookups are done in the parent environment. This is
		# used for Let-like behaviour. Normally, lookups in a child environment are
		# independent, so anything “learnt” in the child environment does not apply
		# to the parent. In certain cases, including Let, things learnt about
		# masked names is not applicable, but things learnt about other names is
		# applicable to the parent, so this copies that information back into the
		# parent.
		force_back : False
		# A list of special names. These are names that have different bindings
		# in the child environment than the parent.
		special_names : []
		# A name to store the environment for later use during code generation.
		name : Required

		# Create masks for all the attributes in a list. Masks are names backed
		# by real expressions, so information about them can translate to the
		# rest of the syntax tree.
		masks_from_definitions : Template {
			# The field containing the list of attributes.
			field : Required
		}
		# Create mask from a name and expression. Masks are names backed by real
		# expressions, so information about them can translate to the rest of the
		# syntax tree.
		mask_from_fields : Template {
			# The field containing the name to mask.
			name_field : Required
			# The field containing the expression to mask.
			expr_field : Required
			# Stores the type occurring at the bottleneck.
			type_storage : Required
		}
		# Create a name backed by an override definition.
		override_name_from_field : Template {
			# The field containing the name.
			field : Required
			# Stores the type occurring at the bottleneck.
			type_storage : Required
		}
		# Create a name from a field where the name must not be used in the new
		# environment. These are used mostly to detect potential circular
		# evaluation.
		forbidden_name : Template {
			# The name.
			name : Required
		}
		# Create a name from a field where the name must not be used in the new
		# environment. These are used mostly to detect potential circular
		# evaluation.
		forbidden_name_from_field : Template {
			# The field containing the name.
			field : Required
		}
	}
	# Check whether the environment is top-level.
	top_level : Template application_action {
		# What value is required in the top-levelness of the environment.
		desired : Required
	}
}
# The actions that can be performed to check that the required return type is
# correct.
ensure_type_tmpl : Template {
	any : Template filter {
		types : For t : type Where t.visible Select t
	}
	bool : Template filter {
		types : [ type.bool ]
	}
	frame : Template filter {
		types : [ type.frame ]
	}
	int : Template filter {
		types : [ type.int ]
	}
	number : Template filter {
		types : [ type.float, type.int ]
	}
	# If true, the value must be unboxed. Otherwise, it will be passed boxed to the generating code.
	needs_unbox : True
	# Check that the return type is one of the supplied types.
	filter : Template {
		# The set of types to restrict the return type. If the return type is not
		# in this set, a type mismatch error will be reported.
		types : Required
		# The action to carry forward with the restricted type.
		ensure_type_of : stop {}
	}
	# Apply the current return type to the return type of other AST nodes.
	propagate : Template {
		# A list of field names that should be restricted to this type.
		fields : Required
		# Any types listed here are added to the return type before propagation.
		# Effectively, this enlarges the return type set. For insight, look at the
		# coalesce operator.
		extra_types : []
	}
	# Apply the current return type to the return type of a collection of other AST nodes.
	propagate_all : Template {
		# The field containing the list.
		field : Required
		# Any types listed here are added to the return type before propagation.
		# See `propagate.extra_types`.
		extra_types : []
	}
	# Restrict the type based on an AST node containing a type literal (e.g., `Enforce` operator).
	dynamic : Template {
		# The field containing the type AST node.
		field : Required
		# Rather than restrict to the type specified, restrict to any type which
		# may be casted to that type.
		propagate_castable : False
		# The action to perform with the restricted type.
		ensure_type_of : stop {}
	}
	# Apply to a stored type
	special : Template {
		type_storage : Required
	}
	# Store the type in a type variable.
	stored : Template {
		# The field containing a list of identifiers with the lookup pieces.
		field : Required
	}
	# Stored associated with the node.
	intrinsic : Template {}
	# Cause all types in the downsteam rules to have exactly the same type.
	shared_fate : Template {
		ensure_type_of : Required
	}
	# Ensure that a type is narrowed to a single type. That is, the union type
	# has a cardinality of one.
	single : Template {
		ensure_type_of : Required
	}
	# Perform no further action.
	stop : Template {}
	# Perform multiple independent actions.
	multiple : Template {
		# A list of actions to perform.
		actions : Required
	}
}
# Templates for making common fields in syntax elements. This is so that some parse rules accumulate results in a single field, such as comments.
common_fields_tmpl : Template {
	str : Template { field_name : Used }
	int : Template { field_name : Used }
	float : Template { field_name : Used }
	other : Template { field_name : Used  item_type : Required }
}
# Code generation for all the elements in the KWS VM. See that documentation for details.
kws_tmpl : Template {
	# The base template for most of the simple instructions.
	base_tmpl : Template codegen.gen_tmpl {
		arguments : Required
		return_type : Required
	}
	binary_length : Template base_tmpl {
		source : Required
		arguments : [ { value : source  item_type : type.bin } ]
		return_type : type.int
	}
	bool_negate : Template base_tmpl {
		source : Required
		arguments : [ { value : source  item_type : type.bool } ]
		return_type : type.bool
	}
	error : Template codegen.gen_tmpl {
		message : Required
	}
	capture : Template base_tmpl {
		source : Required
		arguments : [ { value : source  item_type : type.any } ]
		return_type : type.definition
	}
	int_add : Template base_tmpl {
		left : Required
		right : Required
		arguments : [
			{ value : left  item_type : type.int },
			{ value : right  item_type : type.int }
		]
		return_type : type.int
	}
	int_and : Template base_tmpl {
		left : Required
		right : Required
		arguments : [
			{ value : left  item_type : type.int },
			{ value : right  item_type : type.int }
		]
		return_type : type.int
	}
	int_complement : Template base_tmpl {
		source : Required
		arguments : [ { value : source  item_type : type.int } ]
		return_type : type.int
	}
	int_divide : Template base_tmpl {
		left : Required
		right : Required
		arguments : [
			{ value : left  item_type : type.int },
			{ value : right  item_type : type.int }
		]
		return_type : type.int
	}
	int_modulus : Template base_tmpl {
		left : Required
		right : Required
		arguments : [
			{ value : left  item_type : type.int },
			{ value : right  item_type : type.int }
		]
		return_type : type.int
	}
	int_multiply : Template base_tmpl {
		left : Required
		right : Required
		arguments : [
			{ value : left  item_type : type.int },
			{ value : right  item_type : type.int }
		]
		return_type : type.int
	}
	int_negate : Template base_tmpl {
		source : Required
		arguments : [ { value : source  item_type : type.int } ]
		return_type : type.int
	}
	int_or : Template base_tmpl {
		left : Required
		right : Required
		arguments : [
			{ value : left  item_type : type.int },
			{ value : right  item_type : type.int }
		]
		return_type : type.int
	}
	int_subtract : Template base_tmpl {
		left : Required
		right : Required
		arguments : [
			{ value : left  item_type : type.int },
			{ value : right  item_type : type.int }
		]
		return_type : type.int
	}
	int_xor : Template base_tmpl {
		left : Required
		right : Required
		arguments : [
			{ value : left  item_type : type.int },
			{ value : right  item_type : type.int }
		]
		return_type : type.int
	}
	# Convert an integer to a Boolean by comparing it to a single value.
	int_to_bool : Template base_tmpl {
		# The expression to compute
		source : Required
		# A static integral value to compare against.
		number : Required
		# Whether to invert the result (i.e., not equal rather than equal)
		invert : False
		arguments : [{ value : source  item_type : type.int }]
		return_type : type.bool
	}
	int_to_float : Template base_tmpl {
		expr : Required
		arguments : [{ value : expr  item_type : type.int }]
		return_type : type.float
	}
	float_add : Template base_tmpl {
		left : Required
		right : Required
		arguments : [
			{ value : left  item_type : type.float },
			{ value : right  item_type : type.float }
		]
		return_type : type.float
	}
	float_divide : Template base_tmpl {
		left : Required
		right : Required
		arguments : [
			{ value : left  item_type : type.float },
			{ value : right  item_type : type.float }
		]
		return_type : type.float
	}
	float_is_finite : Template base_tmpl {
		source : Required
		arguments : [ { value : source  item_type : type.float } ]
		return_type : type.bool
	}
	float_is_nan : Template base_tmpl {
		source : Required
		arguments : [ { value : source  item_type : type.float } ]
		return_type : type.bool
	}
	float_modulus : Template base_tmpl {
		left : Required
		right : Required
		arguments : [
			{ value : left  item_type : type.float },
			{ value : right  item_type : type.float }
		]
		return_type : type.float
	}
	float_multiply : Template base_tmpl {
		left : Required
		right : Required
		arguments : [
			{ value : left  item_type : type.float },
			{ value : right  item_type : type.float }
		]
		return_type : type.float
	}
	float_negate : Template base_tmpl {
		source : Required
		arguments : [ { value : source  item_type : type.float } ]
		return_type : type.float
	}
	float_subtract : Template base_tmpl {
		left : Required
		right : Required
		arguments : [
			{ value : left  item_type : type.float },
			{ value : right  item_type : type.float }
		]
		return_type : type.float
	}
	float_to_int : Template base_tmpl {
		expr : Required
		arguments : [{ value : expr  item_type : type.float }]
		return_type : type.int
	}
	string_concatenate : Template base_tmpl {
		first : Required
		second : Required
		arguments : [
			{ value : first  item_type : type.str },
			{ value : second  item_type : type.str }
		]
		return_type : type.str
	}
	string_ordinal : Template base_tmpl {
		source : Required
		arguments : [ { value : source  item_type : type.int } ]
		return_type : type.str
	}
	verify_symbol : Template base_tmpl {
		source : Required
		arguments : [ { value : source  item_type : type.str } ]
		return_type : type.bool
	}
	frame_new : Template codegen.gen_tmpl {
		creation_method : "defined"
		container : Required
		context : Required
		source : Null
	}
	frame_new_through : Template codegen.gen_tmpl {
		container : Required
		context : Required
		start : Required
		end : Required
	}
	frame_null : Template codegen.gen_tmpl {}
	frame_id : Template base_tmpl {
		source : Required
		arguments : [ { value : source  item_type : type.frame } ]
		return_type : type.str
	}
	frame_context : Template base_tmpl {
		source : Required
		arguments : [ { value : source  item_type : type.frame } ]
		return_type : type.context
	}
	frame_container : Template base_tmpl {
		source : Required
		arguments : [ { value : source  item_type : type.frame } ]
		return_type : type.frame
	}
	frame_has : Template base_tmpl {
		source : Required
		name : Required
		arguments : [
			{ value : source  item_type : type.frame },
			{ value : name  item_type : type.str }
		]
		return_type : type.bool
	}
	frame_trace : Template base_tmpl {
		source : Required
		prefix : Required
		arguments : [
			{ value : source  item_type : type.frame },
			{ value : prefix  item_type : type.str }
		]
		return_type : type.str
	}
	ctxt_null : Template codegen.gen_tmpl {}
	ctxt_prepend : Template base_tmpl {
		frame : Required
		tail : Required
		arguments : [
			{ value : frame  item_type : type.frame },
			{ value : tail  item_type : type.context }
		]
		return_type : type.context
	}
	ctxt_append : Template base_tmpl {
		head : Required
		tail : Required
		arguments : [
			{ value : head  item_type : type.context },
			{ value : tail  item_type : type.context }
		]
		return_type : type.context
	}
	lookup_tmpl : Template codegen.gen_tmpl {
		source : Required
	}
	lookup_literal : Template lookup_tmpl {
		name : Required
	}
	lookup_field : Template lookup_tmpl {
		field : Required
	}
	lookup_prefixed : Template lookup_tmpl {
		prefix_field : Required
		suffix_name : Required
	}
	lookup_dynamic : Template lookup_tmpl {
		name : Required
	}
	apply_override : Template base_tmpl {
		override : Required
		original : Required
		arguments : [
			{ value : override  item_type : type.override_definition },
			{ value : original  item_type : type.definition }
		]
		return_type : type.definition
	}
	create_function_tmpl : Template codegen.gen_tmpl {
		returns : Required
	}
	create_override_function : Template create_function_tmpl { }
	create_function : Template create_function_tmpl { }
	set_frame_or_tmpl_tmpl : Template codegen.gen_tmpl {
		into : Required
		with : Required
		# The result to return, since a value must be returned. This can either be
		# `into` to return the collection or `with` to return the item added.
		returns : into
	}
	set_frame_or_tmpl : Template set_frame_or_tmpl_tmpl {
		name : Required
	}
	set_frame_or_tmpl_from_field : Template set_frame_or_tmpl_tmpl {
		name_field : Required
	}

	tmpl_get : Template base_tmpl {
		name : Required
		source : Required
		arguments : [
			{ value : source  item_type : type.template },
			{ value : name  item_type : type.str }
		]
		return_type : type.definition
	}
	tmpl_container : Template base_tmpl {
		source : Required
		arguments : [ { value : source  item_type : type.template } ]
		return_type : type.frame
	}
	tmpl_context : Template base_tmpl {
		source : Required
		arguments : [ { value : source  item_type : type.template } ]
		return_type : type.context
	}
	tmpl_get_from_field : Template base_tmpl {
		source : Required
		field : Required
		arguments : [ { value : source  item_type : type.template } ]
		return_type : type.definition
	}
	tmpl_new : Template codegen.gen_tmpl {
		source : Null
		context : Required
		container : parameters.self_frame
	}

	cast_to_string : Template codegen.gen_tmpl {
		source : Required
	}
	string_constant_tmpl : Template codegen.gen_tmpl {}
	string_constant : Template string_constant_tmpl {
		str : Required
	}
	string_constant_from_field : Template string_constant_tmpl {
		field : Required
	}
	string_length : Template base_tmpl {
		source : Required
		arguments : [ { value : source  item_type : type.str } ]
		return_type : type.int
	}
	# An integral, floating point, or Boolean constant.
	numeric_constant : Template codegen.gen_tmpl {
		# The type of the value
		item_type : Required
		# Either the numeric value, `max`, or `min`.
		number : Required
		# The maximum value this type can take.
		max : Required
		# The minimum value this type can take.
		min : Required
	}
	numeric_constant_units : Template numeric_constant {
		# The unit multiplier
		unit : Used
		# The field containing the value
		field : Required
	}
	# The null value of the unit type.
	null_constant : Template codegen.gen_tmpl {}
	# The not-a-number floating point constant.
	nan_constant : Template codegen.gen_tmpl {}
	# The positive infinity floating point constant
	infinity_constant : Template codegen.gen_tmpl {}

	external_tmpl : Template codegen.gen_tmpl {}
	external_literal : Template external_tmpl {
		uri : Required
	}
	external_from_field : Template external_tmpl {
		field : Required
	}

	# Compare two values of the same type and return an indicator integer.
	compare : Template codegen.gen_tmpl {
		left : Required
		right : Required
	}
	# Branch the current program flow.
	conditional : Template codegen.gen_tmpl {
		# A Boolean value to choose the correct path.
		condition : Required
		# The return value if the condition is true.
		true_action : Required
		# The return value if the condition is false.
		false_action : Required
	}
	# Perform dynamic dispatch of a value. This is slightly different from the VM
	# specification; it must be combined with `codegen.type_dispatch` for the
	# full effect.
	dynamic_type_dispatch_tmpl : Template codegen.gen_tmpl {
		# The code generator which produces an unknown type.
		of : Required
	}
	dynamic_type_dispatch : Template dynamic_type_dispatch_tmpl {
		# The list of types which this value may take. If the object has a
		# different type, a run-time error is produced.
		allow_types : Required
	}
	dynamic_type_dispatch_from_intrinsic : Template dynamic_type_dispatch_tmpl {
		environment : Null
	}
	dynamic_type_dispatch_from_stored_mask : Template dynamic_type_dispatch_tmpl {
		type_storage : Required
	}
	dynamic_type_check_tmpl : Template codegen.gen_tmpl {
		source : Required
	}
	dynamic_type_check : Template dynamic_type_check_tmpl {
		item_type : Required
	}
	dynamic_type_check_parsed : Template dynamic_type_check_tmpl {
		field : Required
	}
	iterator_tmpl : Template codegen.gen_tmpl {
		# The code generation to produce frames and templates over which to be
		# iterated.
		input : Required
		# The initial value for the accumulator of the iterator.
		initial : Required
		# The type of the accumulator.
		accumulator_type : Required
		# Modify the current source reference to include the current iteration item.
		modify_source_reference : False

		# The current attribute name of the iterator. This may only be used in
		# `default_case` and `cases`.
		current_name : Required
		# The current position of the iterator. This may only be used in
		# `default_case` and `cases`.
		current_ordinal : Required
		# The current accumulated value in the iterator.
		current_accumulator : Required

		# The base template for input. Not to be used directly.
		input_tmpl : Template {}
		input_list : Template input_tmpl {
			items : Required
		}
		input_merge : Template input_tmpl {
			field : Required
		}
	}
	# Create a frame merge loop using the provided values as inputs.
	iterator : Template iterator_tmpl {
		# A list of the special cases of the iterator. The special cases will
		# always be invoked, even if they are not present in the input.
		cases : Required
		# The code to be invoked when the iterator has a value not covered in
		# `cases`.
		default_case : Required

		# The base template for a “special case”. Not to be used directly.
		base_case_tmpl : Template {
			# The value to return if this case is selected.
			action : Required
		}
		# The attribute name of the special case is a literal.
		literal_case : Template base_case_tmpl {
			# The attribute name.
			name : Required
		}
		# The attribute name of the special case is defined in a field.
		field_case : Template base_case_tmpl {
			# The field containing the name.
			field : Required
		}
		# The attributes are many based on a list of other syntax elements.
		list_case : Template base_case_tmpl {
			# The field containing the list of elements of interest.
			field : Required
			# The field in the element of interest containing the name.
			name_field : Required
			item_type : Required
			# A name, which may be used in a `other_code` to access the element in the
			# list in `action`.
			current_element : Required
		}
	}
	# Create a frame merge loop using the provided values as inputs, reordered. The type of the ordering is inferred from the instrisic of the current syntax node.
	ordered_iterator : Template iterator_tmpl {
		# The action to perform that must return the ordering value for the current entry.
		build_action : Required
		# The action to perform once the correct order has been determined on each entry.
		process_action : Required
	}
}
# Supplemental code generation. These are more for controlling behaviour of the
# code generator rather than generating code itself. None of these items
# directly generate KWS VM code directly; they simply direct the paths of code
# generation elements in the compiler.
codegen_tmpl : Template {
	# Base template for all code generation templates and KWS VM templates.
	gen_tmpl : Template {}
	# Compute values and make them available in the `parameter` space.
	bind : Template gen_tmpl {
		# A frame of names to bind and the values to which they should be bound.
		define : Required
		# This is a template to be used for the return. It must be a template for
		# rebinding to work correctly.
		in : Required
		# Return the result of `in`. Feel free to set to a `new_parameters` entry.
		returns : Null
		# The results of the computations done in `define`. These will be bound as
		# `parameters` inside the `in` template, but are present here for using as
		# `returns`.
		new_parameters : Required
	}
	collapse_others : Template gen_tmpl {
		# The field containing the list.
		field : Required
		item_type : Required
		# The code generator containing the initial value to put in the fold.
		initial : Required

		# The flavour for accumulation. This should be the accumulating version of
		# the current flavour by default.
		target_flavour : generation_flavour
	}
	# Causes the program to stop running.
	die : Template gen_tmpl {
	}
	# Create a null parameter.
	empty_parameter : Template gen_tmpl {
		in : Required
		emptiness : Required
	}
	# Create a literal list.
	mash_into_frame : Template gen_tmpl {
		field : Required
		target_flavour : generation_flavour
		initial : kws.frame_new {
			creation_method : "list defined"
			container : parameters.self_frame
			context : parameters.context
		}
	}
	# Given a list of syntax elements, fold them to return a single value.
	#
	# Start by computing an initial value. For ever item in the list, call the
	# code generator using either the initial or previous value as input. Return
	# the final value.
	fold_others : Template gen_tmpl {
		# The field containing the list.
		field : Required
		# The code generator containing the initial value to put in the fold.
		initial : Required

		# The flavour for accumulation. This should be the accumulating version of
		# the current flavour by default.
		target_flavour : generation_flavour
	}
	lookup_cached : Template gen_tmpl {
		field : Required
	}
	# Change the value of parameters with new values in a lexically-scoped way.
	mask_parameters : Template gen_tmpl {
		parameters : Required
		action : Required
	}
	# Generate an error if executed. This is a tool to help prototyping new
	# features.
	not_implemented : Template gen_tmpl {}
	# Compute the value of another syntax element
	other_code : Template gen_tmpl {
		# The field containing the syntax element
		field : Required

		target_flavour : generation_flavour
	}
	prepare_lookup_cache : Template gen_tmpl {
		in : Required
		name : Required
		inherit : True
		specials : no_specials {}
		lookup_special_tmpl : Template {}
		specials_from_definitions : Template lookup_special_tmpl {
			field : Required
			target_flavour : generation_flavour
		}
		special_from_expression : Template lookup_special_tmpl {
			type_storage : Required
			field : Required
			is : Required
			target_flavour : generation_flavour
		}
		no_specials : Template lookup_special_tmpl {}
	}
	# Redefine the source reference to include the current syntax element.
	#
	# This isn't done by default since it would fill up the stack with mostly
	# uninformative entires, but it is needed when new frames are created.
	push_source_reference : Template gen_tmpl {
		in : Required
		inherit : True
		syntax : Null
	}
	# Return all possible future types given the limits that were discovered
	# during analysis.
	return_intrinsic_dispatch : Template gen_tmpl {
		of : Required
	}
	# Do some type-dependent behaviour
	type_dispatch_tmpl : Template gen_tmpl {
		# A list of `choice_tmpl` to try.
		choices : Required
		# The action to be performed if none of the supplied types match.
		default_action : codegen.not_implemented {}

		# A possible path to choose based on the type.
		choice_tmpl : Template {
			# The type to match.
			item_type : Required
			# The code to be generated.
			action : Required
		}
	}
	# Choose an appropriate path based on the type of a value.
	type_dispatch : Template type_dispatch_tmpl {
		# This contains the value of the `of` code generator, converted to the
		# appropriate type.
		converted_result : Required
		# The input to be considered.
		of : Required
	}
	type_dispatch_parsed : Template type_dispatch_tmpl {
		# The field containing the type information.
		field : Required
	}

	# Generate code that is aware of the current context, This frame and
	# Container frame.
	flavour_aware : Required
	# Generate code that is aware of the current context, This frame, and
	# Container frame and has a special accumulator for a folding generation.
	flavour_aware_accumulate : Required
	# Generate code that takes no external input.
	flavour_empty : Required
	# Generate code that is unaware of the environment but has an accumulator for
	# folding generation.
	flavour_accumulate : Required
	# Generate code for an attribute. Attributes do not have any context, but do
	# have a source template and a target frame/template being generated.
	flavour_attribute : Required
	# For use in the REPL. There is a root frame and a current frame.
	flavour_repl : Required
}
# All the things to produce API XML files.
apigen_tmpl : Template {
	collect_names : False
	add_name : Template {
		field : Required
		suffixes : []
	}
	add_reference : Template {
		field : Required
	}
	create_node : Template {
		name_field : Required
		main_field : $expression
		description_field : $intro
		informative : False
		actions : Required
	}
	description_text : Template {
		contents_field : Required
	}
	description_tag_tmpl : Template {
		tag : Required
		xmlns : xmlns_xhtml
		attr : {}
		require_prefix : Null
	}
	description_tag : Template description_tag_tmpl {
		contents_field : Required
	}
	description_tag_collapse : Template description_tag_tmpl {
		field : Required
		delimiter : Required
	}
	many : Template {
		actions : Required
	}
	nop : Template many {
		actions : []
	}
	other : Template {
		fields : Required
		collect_names : Used
	}
	other_list : Template {
		field : Required
		collect_names : Used
	}
	xmlns_xhtml : "http://www.w3.org/1999/xhtml"
	xmlns_api : "http://flabbergast.org/api"
}
# The syntax of the Flabbergast language
language_tmpl : Template {
	# The templates to generate the parser, as per `parser_tmpl`.
	parser : Used
	# The templates to generate the common fields, as per `common_fields_tmpl`.
	common_fields : Used
	# A rule that creates a single node in the AST
	syntax_element : Template {
		# The name of AST node. This will be provided by the attribute name. In a
		# parser generated targeting an object-oriented language, this would be the
		# name of the class for each different element in the syntax tree.
		rule_name : Used
		# The name of the group of rules. In a parser generated targeting an
		# object-oriented language, this would be the abstract super-class of a
		# collection of rules.
		group_name : Used
		# The name of this element as the users should see it.
		pretty_name : Required
		# A frame where the names are the names of the “alternative” rules where
		# this syntax element should be included. The values are ignored. In
		# certain cases, for instance, attributes, it is useful to repackage the
		# available syntax elements into different groups that have the same type.
		alternatives : {}
		# The parser generator structure, made from `parser` templates.
		pattern : Required
		# If the syntax group has environment propagation support, this element
		# contains a list of actions to perform, using templates from the
		# `environment` frame, when the environment is being configured.
		apply_environment_to : environment_enabled &&
			Error "apply_environment_to attribute must be overridden in \(rule_name)."
		ensure_type_is : is_typeable &&
			Error "ensure_type_is attribute must be overridden in \(rule_name)."
		# Some syntax elements have parsed other syntax elements which must have
		# specific types. This lists ensure type rules to apply to other syntax
		# elements.
		type_demand : ensure_type.stop {}

		# The code generation value to be returned from this syntax element. It has
		# access to the parameters defined by its group.
		code_value : generation_flavour Is Null ||
			Error "code_value attribute must be overridden in \(rule_name)."

		# If true, this represent a syntax element with all the other fun stuff.
		is_real_element : True
	}
	# This is a special rule that does not define real syntax, but instead,
	# introduce deflection into alternate parsing.
	meandering_element : Template {
		# The name of the rule to be parsed instead.
		alternate_name : Required
		# A frame where the names are the of the “alternative” rules where this
		# element should be included.
		alternatives : {}
		is_real_element : False
	}
	# A group of syntax rules that form a logical group of syntax elements. These
	# should correspond to the single-letter production rules in the
	# specification.
	syntax_group : Template {
		# The `syntax_element` templates to instantiate.
		rules : Template {}
		# This moves fields from the individual AST nodes to the superclass. Each
		# entry is the name of the field and its type (e.g., `name : $str`).
		common : Template {}
		# If true, a parser will be generated that parses all the rules provided in
		# alphabetical order. Otherwise, only individual rules and alternatives
		# will be available for parsing.
		include_base_parser : True
		# The type of syntax checking and name resolution environment associated
		# with this group.
		environment_enabled : False
		# If true, this syntax group has a type and can be the target of type
		# assurances.
		is_typeable : False
		# These are rules that have already been expanded, rather than `rules`
		# where they are templates.
		static_rules : []
		# The type of code generation to be performed. If code is not be generated,
		# null.
		generation_flavour : Null
		alternatives :
			For rule : expanded_rules
			Reduce
				(For alternative_name : Name, acc_value : acc, rule_value : rule.alternatives
				Select alternative_name : Null)
			With acc : {}
		rule_templates : rules {}
		expanded_rules :
			For rule_tmpl : rule_templates, static_rule : static_rules, rule_name : Name
			Select rule_name : static_rule ?? (rule_tmpl {})
		expanded_common : For common_tmpl : common {}, field_name : Name
			Select field_name : common_tmpl {}
	}

	description : Template parser.optional {
		start_word : ""
		accumulate : False
		of : parser.sequence {
			of : [
				space {},
				parser.exact {
					word : start_word & "{{{"
				},
				parser.accumulate_list {
					item_type : $documentation
					field : $intro
					in : parser.many {
						of : parser.other {
							accumulate : True
							item_type : $documentation
							field : Null
						}
					}
				},
				parser.exact {
					word : "}}}"
				}
			]
		}
	}

	pure_space : Template parser.many {
		of : parser.single { char : " \\t\\n\\r\\f\\u000b" }
	}

	# Parse a space and/or comment
	space : Template parser.accumulate_string {
		# Whether there must be some space for successful parsing.
		mandatory : False
		# If `mandatory` is not true, emit a space when pretty printing.
		preferred : False

		field : $comment
		in : parser.many {
			nonempty : mandatory
			of : parser.alternate {
				of : [
					parser.single { char : " \\t\\n\\r\\f\\u000b" },
					parser.sequence {
						of : [
							parser.exact { word : "#" },
							parser.many {
								of : parser.single { char : "\\n"  invert_match : True  accumulate : True }
							},
							parser.single { char : "\\n"  match_eof : True }
						]
					}
				]
			}
		}
	}
	valid_identifier : Template parser.accumulate_string {
		accumulate : True
		in : parser.sequence {
			of : [
				parser.range { from : "a"  to : "z" },
				parser.many {
					of : parser.alternate {
						of : [
							parser.range { from : "a"  to : "z" },
							parser.range { from : "A"  to : "Z" },
							parser.range { from : "0"  to : "9" },
							parser.single { char : "_" }
						]
					}
				}
			]
		}
	}

	expanded_groups :
		For rule_group_tmpl : rule_groups {}, group_name : Name
		Select group_name : rule_group_tmpl {}

	nested_syntax_group : Template syntax_group {
		max_level : Required
		static_rules : For level : 0 Through (max_level - 1)
			Select "zzzz_up_\(level)" : meandering_element {
				alternate_name : group_name & level + 1
				alternatives : For x : [level] Select group_name & x : Null
			}
	}
	nested_syntax_element : Template syntax_element {
		# The depth/precedence in the expression nesting system, as inferred from
		# the specification.
		level : Required
		alternatives : For x : [ level ] Select group_name & x : Null
	}
	# Syntax element for expressions
	expression_tmpl : Template nested_syntax_element {
		# The depth/precedence in the expression nesting system, as inferred from
		# A parser for a top-level expression
		top_expression : Template parser.other {
			accumulate : True
			alternate : $expression0
			item_type : $expression
		}
		# A parser for an expression one level more nested.
		child_expression : Template parser.other {
			accumulate : True
			alternate : "expression" & (level + 1)
			item_type : $expression
		}
		# A parser for an expression of the same level.
		sibling_expression : Template parser.other {
			accumulate : True
			alternate : "expression" & level
			item_type : $expression
		}
	}
	# An expression with two operands separated by a token
	binary_operator : Template expression_tmpl {
		# A string which is the separating token
		operator : Required
		# A template for the right-hand operand, normally a child expression.
		right_operand : Template child_expression { }
		apply_environment_to : [ environment.other_elements { fields : [ $left, $right ] } ]
		pattern : parser.sequence {
			of : [
				child_expression { field : $left },
				space { preferred : True },
				parser.exact { word : operator },
				space { preferred : True },
				right_operand { field : $right }
				]
		}
		api_value : apigen.other { fields : [ $left, $right ] }
	}
	# A binary operator that compare results
	compare_operator : Template binary_operator {
		ensure_type_is : ensure_type.filter { types : [ type.bool ] }
		type_demand : ensure_type.filter {
			types : [ type.bool, type.float, type.int, type.str ]
			ensure_type_of : ensure_type.shared_fate {
				ensure_type_of : ensure_type.propagate { fields : [ $left, $right ] }
			}
		}
		code_value : kws.int_to_bool {
			number : Drop
			invert : Drop
			source : kws.compare {
				left : codegen.other_code { field : $left }
				right : codegen.other_code { field : $right }
			}
		}
	}
	# A binary operator where the right operand is a type.
	type_operator : Template binary_operator {
		apply_environment_to : [ environment.other_elements { fields : [ $left ] } ]
		right_operand : Template parser.other {
			item_type : $type_name
		}
	}
	# An "Is" operator.
	is_suffix_operator : Template binary_operator {
		suffix : Required
		operator : "Is"
		apply_environment_to : [ environment.other_elements { fields : [ $left ] } ]
		api_value : apigen.other { fields : [ $left ] }
		right_operand : Template parser.exact { word : suffix }
	}
	# A unary expression preceded by a token
	unary_tmpl : Template expression_tmpl  {
		# A string which precedes the expression
		operator : Required
		apply_environment_to : [ environment.other_elements { fields : [ $expr ] } ]
		pattern : parser.sequence {
			of : [
				parser.exact { word : operator },
				space { },
				child_expression { field : $expr }
			]
		}
		api_value : apigen.other { fields : [ $expr ] }
	}
	# A expression which is a single word
	literal_tmpl : Template expression_tmpl {
		level : max_level
		apply_environment_to : []
		name : Required
		api_value : apigen.nop {}
		pattern : parser.exact { word : name }
	}
	int_with_unit_expr_tmpl : Template expression_tmpl {
		level : max_level
		unit : Required
		symbol : Required
		api_value : apigen.nop {}
		pattern : int_with_unit_tmpl {}
		pretty_name : "integral value with unit \(symbol)"
		apply_environment_to : [ ]
		ensure_type_is : ensure_type.filter { types : [ type.int ] }
		code_value : kws.numeric_constant_units {
			item_type : type.int
			field : $count
		}
	}
	# A “long” expression (i.e., one containing many terms)
	long_expression_tmpl : Template expression_tmpl {
		# The type of the terms to collect
		term_type : Required
		pattern : parser.sequence {
			of : [
				child_expression { field : $start_expr },
				parser.accumulate_list {
					field : $terms
					item_type : term_type
					in : parser.many {
						nonempty : True
						of : parser.other {
							item_type : term_type
							accumulate : True
							field : Null
						}
					}
				}
			]
		}
		apply_environment_to : [
			environment.other_elements { fields : [ $start_expr ] },
			environment.list_of { field : $terms }
		]
		ensure_type_is : ensure_type.number {
			ensure_type_of : ensure_type.multiple {
				actions : [
					ensure_type.propagate {
						fields : [ $start_expr ]
						extra_types : [ type.int ]
					},
					ensure_type.propagate_all {
						field : $terms
						extra_types : [ type.int ]
					}
				]
			}
		}
		api_value : apigen.many {
			actions : [
				apigen.other { fields : [ $start_expr ] },
				apigen.other_list { field : $terms }
			]
		}
		code_value : codegen.fold_others {
			field : $terms
			initial : codegen.other_code { field : $start_expr }
		}
	}
	# A right-hand term in “long” expression
	long_term_tmpl : Template syntax_element {
		# The precedence level of the term's enclosing expression.
		level : Used
		# The symbol that separates the term.
		symbol : Required
		# The KWS VM operation to perform when the operands are integers.
		integer_operation : Required
		# The KWS VM operation to perform when the operands are floating point numbers.
		float_operation : Required
		apply_environment_to : [ environment.other_elements { fields : [ $expression ] } ]
		ensure_type_is : ensure_type.number {
			ensure_type_of : propagate {
				fields : [ $expression ]
				extra_types : [ type.int ]
			}
		}
		pattern : parser.sequence {
			of : [
				space { preferred : True },
				parser.exact { word : symbol },
				space { preferred : True },
				parser.other {
					accumulate : True
					item_type : $expression
					alternate : "expression" & (level + 1)
					field : $expression
				}
			]
		}
		api_value : apigen.other { fields : [ $expression ] }
		code_value : codegen.type_dispatch {
			of : parameters.accumulator
			left_operation : converted_result

			choices :
				[
					# Left is integer
					choice_tmpl {
						item_type : type.int
						action : codegen.type_dispatch {
							of : codegen.other_code { field : $expression }
							right_operation : converted_result

							choices :
								[
									# Left is integer, right is integer
									choice_tmpl {
										item_type : type.int
										action : integer_operation {
											left : left_operation
											right : right_operation
										}
									},
									# Left is integer, right is float
									choice_tmpl {
										item_type : type.float
										action : float_operation {
											left : kws.int_to_float {
												expr : left_operation
											}
											right : right_operation
										}
									}
								]
						}
					},
					# Left is float
					choice_tmpl {
						item_type : type.float
						action : codegen.type_dispatch {
							of : codegen.other_code { field : $expression }
							right_operation : converted_result

							choices :
								[
									# Left is float, right is integer
									choice_tmpl {
										item_type : type.int
										action : float_operation {
											left : left_operation
											right : kws.int_to_float {
												expr : right_operation
											}
										}
									},
									# Left is float, right is float
									choice_tmpl {
										item_type : type.float
										action : float_operation {
											left : left_operation
											right : right_operation
										}
									}
								]
						}
					}
				]
		}
	}
	# A decimal number with no preceding zeros.
	valid_number : Template parser.alternate {
		multiplier : 10
		offset : 48
		of : [
			parser.exact { word : "0" },
			parser.sequence {
				of : [
					parser.range { from : "1"  to : "9"  accumulate : True },
					parser.many {
						of : parser.range { from : "0"  to : "9"  accumulate : True }
					}
				]
			}
		]
	}

	# A single hexidecimal digit
	hex_digit : Template parser.alternate {
		multiplier : 16
		of : [
			parser.range {
				offset : 48
				accumulate : True
				from : "0"  to : "9"
			},
			parser.range {
				offset : 87
				accumulate : True
				from : "a"  to : "f"
			},
			parser.range {
				offset : 55
				accumulate : True
				from : "A"  to : "F"
			}
		]
	}
	int_with_unit_tmpl : Template parser.sequence {
		symbol : Used
		unit : Used
		of : [
			parser.accumulate_integer {
				in : valid_number {}
				field : $count
			},
			parser.exact { word : symbol }
		]
	}
	# The general pattern for normal attribute definitions
	attribute_pattern : Template parser.sequence {
		allow_description : False
		value_pattern : Template parser.other {
			item_type : $expression
			alternate : $expression0
			field : $expression
		}
		of : [
			If allow_description Then description {} Else Null,
			space { preferred : True },
			valid_identifier { field : $name },
			space { preferred : True },
			parser.exact { word : ":" },
			space { preferred : True },
			value_pattern { }
		]
	}
	uri : Template parser.accumulate_string {
		field : $uri
		in : parser.sequence {
			accumulate : True
			of : [
				parser.many {
					of : parser.alternate {
						of : [
							parser.range { from : "A"  to : "Z" },
							parser.range { from : "a"  to : "z" },
							parser.range { from : "0"  to : "9" },
							parser.single { char : "-.+" }
						]
					}
				},
				parser.single { char : ":" },
				parser.many {
					of : parser.alternate {
						of : [
							parser.range { from : "A"  to : "Z" },
							parser.range { from : "a"  to : "z" },
							parser.range { from : "0"  to : "9" },
							parser.single { char : "~=-,;!?/.'_[]@$*&#%+:" }
						]
					}
				}
			]
		}
	}
	doc_text : Template parser.accumulate_string {
		field : $str
		accumulate : True
		in : parser.many {
			nonempty : True
			of : parser.alternate {
				of : [
					parser.single {
						char : "\\\\}"
						invert_match : True
					},
					parser.collect_codepoint {
						codepoint : 0x40
						in : parser.exact {
							word : "\\\\\\\\"
						}
					},
					parser.collect_codepoint {
						codepoint : 0x3E
						in : parser.exact {
							word : "\\\\}"
						}
					}
				]
			}
		}
	}
	function_tmpl : Template expression_tmpl {
		level : 20
		has_anon_args : Required
		has_named_args : Required
		parse_anonymous : Template parser.accumulate_list {
			field : $anon_args
			item_type : $expression
			in : parser.many_word {
				of : parser.sequence {
					of : [
						space { preferred : True },
						top_expression { field : Null },
						space { },
						parser.except { char : ":" }
					]
				}
				separator_word : ","
			}
		}
		parse_named : Template parser.accumulate_list {
			field : $named_args
			item_type : $named_definition
			deduplicate : expanded_groups.named_definition.expanded_common.name
			forbid :
				If has_anon_args
					Then [ $args, $value ]
					Else [ $value ]
			in : parser.many_word {
				nonempty : True
				of : parser.sequence {
					of : [
						parser.other {
							item_type : $named_definition
							field : Null
						},
						space { }
					]
				}
				separator_word : ","
			}
		}

		pattern : parser.sequence {
			of : [
				child_expression { field : $func_expr },
				space { },
				parser.exact { word : "(" },
				If has_anon_args Then parse_anonymous {} Else parser.nop {},
				If has_anon_args && has_named_args Then parser.exact { word : "," } Else parser.nop {},
				If has_named_args Then parse_named {} Else parser.nop {},
				space { },
				parser.exact { word : ")" }
			]
		}
		apply_environment_to : [
			environment.other_elements { fields : [ $func_expr ] },
			If has_anon_args Then environment.list_of { field : $anon_args } Else Null,
			If has_named_args Then environment.list_of { field : $named_args } Else Null
		]
		ensure_type_is : ensure_type.intrinsic {
			needs_unbox : False
		}
		type_demand : ensure_type.multiple {
			actions : [
				ensure_type.filter {
					types : [ type.template ]
					ensure_type_of : ensure_type.propagate { fields : [ $func_expr ] }
				},
				If has_anon_args
					Then ensure_type.propagate_all { needs_unbox : False  field : $anon_args }
					Else ensure_type.stop {},
				If has_named_args
					Then ensure_type.propagate_all { needs_unbox : False  field : $named_args }
					Else ensure_type.stop {}
			]
		}
		api_value : apigen.many {
			actions : [
				apigen.other { fields : [ $func_expr ] },
				If has_anon_args
					Then apigen.other_list { field : $anon_args }
					Else apigen.nop {},
				If has_named_args
					Then apigen.other_list { field : $named_args }
					Else apigen.nop {}
			]
		}
		code_value : codegen.return_intrinsic_dispatch {
			of : kws.lookup_literal {
				name : [ $value ]
				source : kws.ctxt_prepend {
					tail : kws.ctxt_null {}
					frame : codegen.type_dispatch {
						of : codegen.other_code { field : $func_expr }
						choices : [
							choice_tmpl {
								item_type : type.template
								action : kws.iterator {
									accumulator_type : type.mutable_frame
									input : input_list {
										items : [ converted_result ]
									}
									initial : codegen.push_source_reference {
										in : kws.frame_new {
											creation_method : "function-like instantiation"
											container : kws.tmpl_container { source : converted_result }
											context : kws.tmpl_context { source : converted_result }
										}
									}
									cases : [
										If has_anon_args
											Then literal_case {
												name : $args
												action : kws.set_frame_or_tmpl {
													name : current_name
													returns : into
													into : current_accumulator
													with : codegen.mash_into_frame {
														field : $anon_args
													}
												}
											}
											Else Null,
										If has_named_args
											Then list_case {
												field : $named_args
												name_field : $name
												item_type : $named_definition
												action : kws.set_frame_or_tmpl {
													name : current_name
													returns : into
													into : current_accumulator
													with : codegen.other_code {
														field : current_element
													}
												}
											}
											Else Null
									]
									default_case : kws.set_frame_or_tmpl {
										name : current_name
										returns : into
										into : current_accumulator
										with : kws.tmpl_get {
											name : current_name
											source : converted_result
										}
									}
								}
							}
						]
					}
				}
			}
		}
	}
	selector_tmpl : Template nested_syntax_element {
		# A parser for a selector one level more nested.
		child_selector : Template parser.other {
			accumulate : True
			alternate : group_name & (level + 1)
			item_type : group_name
		}
	}
	perform_overrides : Template codegen.push_source_reference {
		accumulator_type : Required
		source_template : Required
		new_item : Required
		in : codegen.type_dispatch {
			of : source_template
			choices : [
				choice_tmpl {
					item_type : type.template
					action : kws.iterator {
						accumulator_type : Drop
						initial : new_item {
							source : converted_result
							context : kws.ctxt_append {
								head : parameters.context
								tail : kws.tmpl_context { source : converted_result }
							}
						}
						input : input_list {
							items : [ converted_result ]
						}
						cases : [ list_case {
							field : $overrides
							name_field : $name
							item_type : $attribute
							action : codegen.other_code {
								parameters : {
									source_template : converted_result
									target : current_accumulator
								}
								field : current_element
								target_flavour : codegen.flavour_attribute
							}
						}]
						default_case : kws.set_frame_or_tmpl {
							name : current_name
							returns : into
							into : current_accumulator
							with : kws.tmpl_get {
								name : current_name
								source : converted_result
							}
						}
					}
				}
			]
		}
	}
	fricassee_iterator : Template codegen.bind {
		accumulator_type : type.mutable_frame
		start : Required
		step : Required

		define : {
			input_frame : codegen.other_code { field : $selector }
		}
		in : Template kws.iterator {
			accumulator_type : Drop
			modify_source_reference : True
			input : input_list {
				items : [ parameters.input_frame ]
			}
			cases : []
			initial : start {}

			default_case : codegen.bind {
				define : {
					current_itr_frame : kws.lookup_dynamic {
						name : current_name
						source : kws.ctxt_prepend {
							frame : parameters.input_frame
							tail : kws.ctxt_null {}
						}
					}
				}
				in : Template codegen.bind {
					define : {
						context : kws.ctxt_prepend {
							frame : kws.dynamic_type_dispatch {
								allow_types : [ type.frame ]
								of : parameters.current_itr_frame
							}
							tail : parameters.context
						}
					}
					in : Template codegen.prepare_lookup_cache {
						name : $select_env
						in : step {}
					}
				}
			}
		}
	}

# The definitions for all the types in the Flabbergast language.
	type_definition_tmpl : Template {
		name : Required
		visible : False
		castable_from : []
	}
	type_definitions : Template {
		bin : Template type_definition_tmpl {
			name : "Bin"
			visible : True
		}
		bool : Template type_definition_tmpl {
			name : "Bool"
			visible : True
		}
		float : Template type_definition_tmpl {
			name : "Float"
			visible : True
			castable_from : [ type.int ]
		}
		frame : Template type_definition_tmpl {
			name : "Frame"
			visible : True
		}
		int : Template type_definition_tmpl {
			name : "Int"
			visible : True
			castable_from : [ type.float ]
		}
		null : Template type_definition_tmpl {
			name : "Null"
			visible : True
		}
		str : Template type_definition_tmpl {
			name : "Str"
			visible : True
			castable_from : [ type.bool, type.float, type.int ]
		}
		template : Template type_definition_tmpl {
			name : "Template"
			visible : True
		}
		any : Template type_definition_tmpl {
			name : "Any"
		}
		mutable_frame : Template type_definition_tmpl {
			name : "Frame"
		}
		context : Template type_definition_tmpl {
			name : "Context"
		}
		definition : Template type_definition_tmpl {
			name : "Definition"
		}
		override_definition : Template type_definition_tmpl {
			name : "OverrideDefinition"
		}
	}
	type : For t : type_definitions {}, short_name : Name
		Accumulate m * 2 With m : 1
		Select short_name : t { mask : m }

	# All the groups in the language. For details, see the specification.
	rule_groups : Template {
		file : Template syntax_group {
			environment_enabled : True
			generation_flavour : codegen.flavour_empty
			collect_names : True
			common +: {
				comment : common_fields.str
			}
			rules +: {
				file : Template syntax_element {
					pretty_name : "file contents"
					pattern : parser.sequence {
						of : [
							description {
								start_word : "Introduction"
							},
							parser.accumulate_list {
								field : $attributes
								item_type : $attribute
								deduplicate : expanded_groups.attribute.expanded_common.name
								in : parser.many {
									of : parser.sequence {
										of : [
												pure_space {},
												parser.other {
												item_type : $attribute
												alternate : $plain_attribute
												field : Null
											}
										]
									}
									nonempty : True
								}
							},
							space { }
						]
					}
					apply_environment_to : [ environment.list_independent {
						field : $attributes
						top_level : True
					} ]
					api_value : apigen.many {
						actions : [
							apigen.other_list { field : $intro },
							apigen.other_list { field : $attributes }
						]
					}
					code_value : codegen.push_source_reference {
						inherit : False
						in : codegen.empty_parameter {
							parameters : {
								context : emptiness
								self_frame : emptiness
								container_frame : emptiness
								source_template : emptiness
							}
							in : codegen.collapse_others {
								item_type : type.mutable_frame
								target_flavour : codegen.flavour_attribute_accumulate
								field : $attributes
								initial : kws.frame_new {
									creation_method : "file-level definition"
									container : kws.frame_null {}
									context : kws.ctxt_null {}
								}
							}
						}
					}
				}
			}
		}
		documentation : Template syntax_group {
			environment_enabled : False
			generation_flavour : Null
			rules +: {
				emph : Template syntax_element {
					pretty_name : "attribute"
					pattern : parser.sequence {
						of : [
							parser.exact { word : "\\\\Emph{" },
							doc_text {},
							parser.exact { word : "}" }
						]
					}
					api_value : apigen.description_tag {
						tag : "em"
						contents_field : $str
					}
				}
				from : Template syntax_element {
					pretty_name : "attribute"
					pattern : parser.sequence {
						of : [
							parser.exact { word : "\\\\From{" },
							uri {},
							parser.exact { word : "}" }
						]
					}
					api_value : apigen.many {
						actions : [
							apigen.add_reference { field : $uri },
							apigen.description_tag {
								tag : "o_0:ref"
								xmlns : xmlns_api
								require_prefix : "lib:"
								contents_field : $uri
							}
						]
					}
				}
				link : Template syntax_element {
					pretty_name : "attribute"
					pattern : parser.sequence {
						of : [
							parser.exact { word : "\\\\Link{" },
							uri {},
							parser.exact { word : "|" },
							doc_text {},
							parser.exact { word : "}" }
						]
					}
					api_value : apigen.description_tag {
						tag : "a"
						contents_field : $str
						attr : {
							href : $uri
						}
					}
				}
				lookup : Template syntax_element {
					pretty_name : "attribute"
					pattern : parser.sequence {
						of : [
							parser.exact { word : "\\\\{" },
							parser.accumulate_list {
								item_type : $identifier
								field : $names
								in : parser.many_word {
									of : parser.other {
										item_type : $identifier
										field : Null
									}
									separator_word : "."
								}
							},
							parser.exact { word : "}" }
						]
					}
					api_value : apigen.description_tag_collapse {
						field : $names
						tag : "o_0:use"
						xmlns : xmlns_api
						delimiter : "."
					}
				}
				mono : Template syntax_element {
					pretty_name : "attribute"
					pattern : parser.sequence {
						of : [
							parser.exact { word : "\\\\Mono{" },
							doc_text {},
							parser.exact { word : "}" }
						]
					}
					api_value : apigen.description_tag {
						tag : "tt"
						contents_field : $str
					}
				}
				text : Template syntax_element {
					pretty_name : "attribute"
					pattern : doc_text {}
					api_value : apigen.description_text {
						contents_field : $str
					}
				}
			}
		}

		attribute : Template syntax_group {
			include_base_parser : False
			environment_enabled : True
			generation_flavour : codegen.flavour_attribute
			collect_names : True
			is_typeable : True
			missing_attribute_tmpl : Template syntax_element {
				pattern_suffix : Required
				pattern : parser.sequence {
					of : [
						description {},
						space { preferred : True },
						valid_identifier { field : $name },
						pattern_suffix {}
					]
				}
				apply_environment_to : [ ]
				ensure_type_is : ensure_type.any { }
				api_value : apigen.create_node {
					name_field : $name
					main_field : Null
					actions : [ ]
				}
				code_value : kws.set_frame_or_tmpl_from_field {
					name_field : $name
					returns : into
					into : parameters.target
					with : kws.create_function {
						returns : codegen.push_source_reference {
							in : kws.error {
								message : kws.string_concatenate {
									first : kws.string_constant { str : "Attribute “" }
									second : kws.string_concatenate {
										first : kws.string_constant_from_field { field : $name }
										second : kws.string_constant { str : "” must be overridden." }
									}
								}
							}
						}
					}
				}
			}
			common +: {
				comment : common_fields.str
				name : common_fields.str
			}
			rules +: {
				plain_attribute : Template syntax_element {
					pretty_name : "attribute"
					alternatives : { new_tmpl_attributes : Null  extend_tmpl_attributes : Null  instantiate_tmpl_attributes : Null  function_tmpl_attributes : Null }
					pattern : attribute_pattern { allow_description : True }
					apply_environment_to : [
						environment.modified_environment {
							apply_to : [ environment.other_elements { fields : [ $expression ] } ]
							special_names : [ forbidden_name_from_field { field : $name } ]
							force_back : True
							name : $inner_environment
						}
					]
					type_demand : ensure_type.propagate {
						fields : [ $expression ]
						needs_unbox : False
					}
					ensure_type_is : ensure_type.propagate {
						fields : [ $expression ]
						needs_unbox : False
					}
					api_value : apigen.create_node {
						name_field : $name
						actions : [
							apigen.other { fields : [ $expression ] }
						]
					}
					code_value : kws.set_frame_or_tmpl_from_field {
						name_field : $name
						returns : into
						into : parameters.target
						with : kws.create_function {
							returns : codegen.push_source_reference {
								in : codegen.prepare_lookup_cache {
									in : codegen.prepare_lookup_cache {
										in : codegen.other_code { field : $expression }
										name : $inner_environment
									}
									name : Null
								}
							}
						}
					}
				}
				named_override : Template syntax_element {
					pretty_name : "attribute with named override"
					alternatives : { extend_tmpl_attributes : Null  instantiate_tmpl_attributes : Null }
					pattern : parser.sequence {
						of : [
							description {},
							space { preferred : True },
							valid_identifier { field : $name },
							space { preferred : True },
							parser.exact { word : "+" },
							valid_identifier { field : $temporary_name },
							parser.exact { word : ":" },
							space { preferred : True },
							parser.other {
								item_type : $expression
								alternate : $expression0
								field : $expression
							}
						]
					}
					apply_environment_to : [ environment.modified_environment {
						apply_to : [ environment.other_elements { fields : [ $expression ] } ]
						special_names : [
							override_name_from_field {
								field : $temporary_name
								type_storage : $override_bottleneck
							},
							forbidden_name_from_field { field : $name }
						]
						name : $inner_environment
					} ]
					type_demand : ensure_type.propagate {
						fields : [ $expression ]
						needs_unbox : False
					}
					ensure_type_is : ensure_type.propagate {
						fields : [ $expression ]
						needs_unbox : False
					}
					api_value : apigen.create_node {
						name_field : $name
						actions : [
							apigen.other { fields : [ $expression ] }
						]
					}
					code_value : kws.set_frame_or_tmpl_from_field {
						name_field : $name
						returns : into
						into : parameters.target
						with : kws.apply_override {
							override : kws.create_override_function {
								returns : codegen.push_source_reference {
									in : codegen.prepare_lookup_cache {
										in : codegen.prepare_lookup_cache {
											specials : special_from_expression {
												field : $temporary_name
												is : parameters.original_value
												type_storage : $override_bottleneck
											}
											in : codegen.other_code { field : $expression }
											name : $inner_environment
										}
										name : Null
									}
								}
							}
							original : kws.tmpl_get_from_field {
								field : $name
								source : parameters.source_template
							}
						}
					}
				}
				template_override : Template syntax_element {
					pretty_name : "attribute overriding a template"
					alternatives : { extend_tmpl_attributes : Null  instantiate_tmpl_attributes : Null }

					pattern : parser.sequence {
						of : [
							description {},
							space { preferred : True },
							valid_identifier { field : $name },
							space { preferred : True },
							parser.exact { word : "+:" },
							space { preferred : True },
							parser.exact { word : "{" },
							parser.accumulate_list {
								field : $overrides
								item_type : $attribute
								in : parser.many {
									of : parser.sequence {
										of : [
											pure_space {},
											parser.other {
												item_type : $attribute
												alternate : $extend_tmpl_attributes
												field : Null
											}
										]
									}
								}
							},
							space { preferred : True },
							parser.exact { word : "}" },
							space { preferred : True }
						]
					}
					api_value : apigen.create_node {
						name_field : $name
						main_field : Null
						actions : [
							apigen.other_list { field : $overrides }
						]
					}
					apply_environment_to : [ environment.list_independent { field : $overrides } ]
					ensure_type_is : ensure_type.filter {
						types : [ type.template ]
					}
					code_value : kws.set_frame_or_tmpl_from_field {
						name_field : $name
						returns : into
						into : parameters.target
						with : kws.apply_override {
							override : kws.create_override_function {
								returns : perform_overrides {
									accumulator_type : type.template
									new_item : kws.tmpl_new
									source_template : kws.dynamic_type_dispatch {
										allow_types : [ type.template ]
										of : parameters.original_value
									}
								}
							}
							original : kws.tmpl_get_from_field {
								field : $name
								source : parameters.source_template
							}
						}
					}
				}
				missing_attribute : Template missing_attribute_tmpl {
					pretty_name : "attribute requiring override"
					alternatives : { new_tmpl_attributes : Null  extend_tmpl_attributes : Null }
					pattern_suffix : Template parser.sequence {
						of : [
							space { preferred : True },
							parser.exact { word : ":" },
							space { preferred : True },
							parser.exact { word : "Required" }
						]
					}
				}
				zz_missing_name : Template missing_attribute_tmpl {
					pretty_name : "function-like template required argument"
					alternatives : { function_tmpl_attributes : Null }
					pattern_suffix : parser.nop
				}
				informative_attribute : Template syntax_element {
					pretty_name : "informative attribute"
					alternatives : { extend_tmpl_attributes : Null  instantiate_tmpl_attributes : Null }
					pattern : parser.sequence {
						of : [
							description {},
							space { preferred : True },
							valid_identifier { field : $name },
							space { preferred : True },
							parser.exact { word : ":" },
							space { preferred : True },
							parser.exact { word : "Used" }
						]
					}
					apply_environment_to : [ ]
					ensure_type_is : ensure_type.any { }
					api_value : apigen.create_node {
						name_field : $name
						informative : True
						actions : []
					}
					code_value : kws.set_frame_or_tmpl_from_field {
						name_field : $name
						returns : into
						into : parameters.target
						with : kws.tmpl_get_from_field {
							field : $name
							source : parameters.source_template
						}
					}
				}
				informative_attribute_new : Template rule_templates.informative_attribute {
					alternatives : { new_tmpl_attributes : Null }
					ensure_type_is : ensure_type.any { }
					code_value : parameters.target
				}
				remove_attribute : Template syntax_element {
					pretty_name : "removal attribute"
					alternatives : { extend_tmpl_attributes : Null  instantiate_tmpl_attributes : Null }
					pattern : parser.sequence {
						of : [
							description {},
							space { preferred : True },
							valid_identifier { field : $name },
							space { preferred : True },
							parser.exact { word : ":" },
							space { preferred : True },
							parser.exact { word : "Drop" }
						]
					}
					apply_environment_to : [ ]
					ensure_type_is : ensure_type.any { }
					api_value : apigen.create_node {
						name_field : $name
						informative : True
						actions : []
					}
					code_value : parameters.target
				}
				eager_attribute : Template syntax_element {
					pretty_name : "eagerly evaluated attribute"
					alternatives : { new_tmpl_attributes : Null  extend_tmpl_attributes : Null  instantiate_tmpl_attributes : Null  function_tmpl_attributes : Null }
					pattern : parser.sequence {
						of : [
							description {},
							space { preferred : True },
							valid_identifier { field : $name },
							space { preferred : True },
							parser.exact { word : ":" },
							space { preferred : True },
							parser.exact { word : "Now" },
							space { mandatory : True },
							parser.other {
								item_type : $expression
								alternate : $expression0
								field : $expression
							}
						]
					}
					apply_environment_to : [
						environment.modified_environment {
							apply_to : [ environment.other_elements { fields : [ $expression ] } ]
							force_back : True
							name : $inner_environment
						}
					]
					type_demand : ensure_type.propagate {
						fields : [ $expression ]
						needs_unbox : False
					}
					ensure_type_is : ensure_type.propagate {
						fields : [ $expression ]
						needs_unbox : False
					}
					api_value : apigen.create_node {
						name_field : $name
						actions : [
							apigen.other { fields : [ $expression ] }
						]
					}
					code_value : kws.set_frame_or_tmpl_from_field {
						name_field : $name
						returns : into
						into : parameters.target
						with : kws.capture {
							source : codegen.push_source_reference {
								in : codegen.prepare_lookup_cache {
									in : codegen.other_code {
										field : $expression
										target_flavour : codegen.flavour_aware
									}
									name : $inner_environment
								}
							}
						}
					}
				}
			}
		}

		named_definition : Template syntax_group {
			environment_enabled : True
			generation_flavour : codegen.flavour_aware
			is_typeable : True
			common +: {
				comment : common_fields.str
				name : common_fields.str
			}
			rules +: {
				definition : Template syntax_element {
					pretty_name : "named definition"
					pattern : attribute_pattern {}
					apply_environment_to : [ environment.other_elements { fields : [ $expression ] } ]
					ensure_type_is : ensure_type.any { ensure_type_of : propagate { fields : [ $expression ] } }
					api_value : apigen.other { fields : [ $expression ] }
					code_value : codegen.other_code { field : $expression }
				}
			}
		}

		selector : Template nested_syntax_group {
			max_level : 4
			environment_enabled : True
			generation_flavour : codegen.flavour_aware
			common +: {
				comment : common_fields.str
			}
			rules +: {
				order_by : Template selector_tmpl {
					level : 0
					pretty_name : "fricassée Order By clause"
					pattern : parser.sequence {
						of : [
							child_selector { field : $selector },
							parser.exact { word : "Order" },
							space { mandatory : True },
							parser.exact { word : "By" },
							space { mandatory : True },
							parser.other {
								item_type : $expression
								alternate : $expression0
								field : $expression
							},
							space { preferred : True }
						]
					}
					apply_environment_to : [
						environment.other_with_result {
							field : $selector
							name : $select_env
							apply_to : [
								environment.other_elements { fields : [ $expression ] },
								environment.collect { }
							]
						}
					]
					type_demand : ensure_type.shared_fate {
						ensure_type_of : ensure_type.multiple {
							actions : [
								ensure_type.single {
									ensure_type_of : ensure_type.filter {
										types : [ type.int, type.float, type.str ]
										ensure_type_of : ensure_type.propagate { fields : [ $expression ] }
									}
								},
								ensure_type.intrinsic {}
							]
						}
					}
					api_value : apigen.other { fields : [ $selector, $expression ] }
					code_value : codegen.bind {
						define : {
							input_frame : codegen.other_code { field : $selector }
						}
						in : Template kws.ordered_iterator {
							accumulator_type : type.mutable_frame

							modify_source_reference : True
							input : input_list {
								items : [ parameters.input_frame ]
							}
							initial : kws.frame_new {
								container : parameters.self_frame
								context : parameters.context
							}
							build_action : codegen.bind {
								define : {
									context : kws.ctxt_prepend {
										frame : kws.dynamic_type_dispatch {
											allow_types : [ type.frame ]
											of : kws.lookup_dynamic {
												name : current_name
												source : kws.ctxt_prepend {
													frame : parameters.input_frame
													tail : kws.ctxt_null {}
												}
											}
										}
										tail : parameters.context
									}
								}
								in : Template codegen.prepare_lookup_cache {
									name : $select_env
									in : codegen.other_code { field : $expression }
								}
							}

							process_action : kws.set_frame_or_tmpl {
								returns : into
								name : kws.string_ordinal {
									source : current_ordinal
								}
								into : current_accumulator
								with : kws.lookup_dynamic {
									name : current_name
									source : kws.ctxt_prepend {
										frame : parameters.input_frame
										tail : kws.ctxt_null {}
									}
								}
							}
						}
					}
				}
				reverse : Template selector_tmpl {
					level : 0
					pretty_name : "fricassée Reverse clause"
					pattern : parser.sequence {
						of : [
							child_selector { field : $selector },
							parser.exact { word : "Reverse" },
							space { mandatory : True }
						]
					}
					apply_environment_to : [
						environment.other_with_result {
							field : $selector
							name : $select_env
							apply_to : [
								environment.collect { }
							]
						}
					]
					api_value : apigen.other { fields : [ $selector ] }
					code_value : fricassee_iterator {
						start : Template kws.frame_new {
							container : parameters.self_frame
							context : parameters.context
						}
						step : Template kws.set_frame_or_tmpl {
							returns : into
							name : kws.string_ordinal {
								source : kws.int_negate {
									source : current_ordinal
								}
							}
							into : current_accumulator
							with : parameters.current_itr_frame
						}
					}
				}

				where : Template selector_tmpl {
					level : 1
					pretty_name : "fricassée Where clause"
					pattern : parser.sequence {
						of : [
							child_selector { field : $selector },
							parser.exact { word : "Where" },
							space { mandatory : True },
							parser.other {
								item_type : $expression
								alternate : $expression0
								field : $expression
							},
							space { preferred : True }
						]
					}
					apply_environment_to : [
						environment.other_with_result {
							field : $selector
							name : $select_env
							apply_to : [
								environment.other_elements { fields : [ $expression ] },
								environment.modified_environment {
									name : $target_env
									apply_to : [ environment.collect { } ]
								}
							]
						}
					]
					type_demand : ensure_type.bool {
						ensure_type_of : ensure_type.propagate { fields : [ $expression ] }
					}
					api_value : apigen.other { fields : [ $selector, $expression ] }
					code_value : fricassee_iterator {
						start : Template kws.frame_new {
							container : parameters.self_frame
							context : parameters.context
						}
						step : Template kws.conditional {
							condition : codegen.other_code { field : $expression }
							false_action : current_accumulator
							true_action : kws.set_frame_or_tmpl {
								returns : into
								name : current_name
								into : current_accumulator
								with : parameters.current_itr_frame
							}
						}
					}
				}

				let : Template selector_tmpl {
					pretty_name : "fricassée Let"
					level : 3
					pattern : parser.sequence {
						of : [
							child_selector { field : $selector },
							parser.exact { word : "Let" },
							space { mandatory : True },
							parser.accumulate_list {
								item_type : $named_definition
								field : $definitions
								deduplicate : expanded_groups.named_definition.expanded_common.name
								in : parser.many_word {
									of : parser.other { item_type : $named_definition  field : Null }
									separator_word : ","
									nonempty : True
								}
							},
							space { preferred : True }
						]
					}
					apply_environment_to : [
						environment.other_with_result {
							field : $selector
							name : $select_env
							apply_to : [
								environment.list_of { field : $definitions },
								environment.modified_environment {
									force_back : True
									special_names : [ masks_from_definitions { field : $definitions } ]
									apply_to : [ environment.collect { } ]
									name : $inner_environment
								}
							]
						}
					]
					type_demand : ensure_type.propagate_all {
						field : $definitions
					}
					api_value : apigen.many {
						actions : [
							apigen.other { fields : [ $selector ] },
							apigen.other_list { field : $definitions }
						]
					}
					code_value : fricassee_iterator {
						accumulator_type : type.mutable_frame
						start : Template kws.frame_new {
							creation_method : pretty_name
							container : parameters.self_frame
							context : parameters.context
						}
						step : Template kws.set_frame_or_tmpl {
							returns : into

							name : current_name
							into : current_accumulator
							with : codegen.bind {
								define : {
									current_itr_frame : kws.dynamic_type_dispatch {
										of : parameters.current_itr_frame
										allow_types : [ type.frame ]
									}
									context : kws.ctxt_prepend {
										frame : kws.dynamic_type_dispatch {
											of : parameters.current_itr_frame
											allow_types : [ type.frame ]
										}
										tail : parameters.context
									}
								}
								in : Template codegen.push_source_reference {
									in : kws.iterator {
										accumulator_type : type.mutable_frame
										input : input_list {
											items : [ parameters.current_itr_frame ]
										}
										initial : kws.frame_new {
											creation_method : pretty_name
											container : parameters.self_frame
											context : parameters.context
										}
										default_case : kws.set_frame_or_tmpl {
											returns : into
											name : current_name
											into : current_accumulator
											with : kws.lookup_dynamic {
												name : current_name
												source : kws.ctxt_prepend {
													frame : parameters.current_itr_frame
													tail : kws.ctxt_null {}
												}
											}
										}
										cases : [
											list_case {
												field : $definitions
												name_field : $name
												item_type : $named_definition
												action : kws.set_frame_or_tmpl {
													returns : into
													name : current_name
													into : current_accumulator
													with : codegen.other_code {
														field : current_element
													}
												}
											}
										]
									}
								}
							}
						}
					}
				}

				accumulate : Template selector_tmpl {
					pretty_name : "fricassée Accumulate"
					level : 2
					pattern : parser.sequence {
						of : [
							child_selector { field : $selector },
							parser.exact { word : "Accumulate" },
							space { mandatory : True },
							parser.other { item_type : $expression  alternate : $expression0  field : $reduce_expr },
							space { mandatory : True },
							parser.exact { word : "With" },
							space { mandatory : True },
							valid_identifier { field : $initial_name },
							space { preferred : True },
							parser.exact { word : ":" },
							space { preferred : True },
							parser.other { item_type : $expression  alternate : $expression0  field : $initial_expr },
							space { preferred : True }
						]
					}
					apply_environment_to : [
						environment.other_elements {
							fields : [ $initial_expr ]
						},
						environment.other_with_result {
							field : $selector
							name : $select_env
							apply_to : [
								environment.modified_environment {
									name : $reduce_env
									special_names : [ mask_from_fields {
										name_field : $initial_name
										expr_field : $initial_expr
										type_storage : $bottleneck_type
									} ]
									apply_to : [
										environment.other_elements { fields : [ $reduce_expr ] },
										environment.collect { }
									]
								}
							]
						}
					]
					api_value : apigen.other { fields : [ $selector, $initial_expr, $reduce_expr ] }
					type_demand : ensure_type.propagate {
						fields : [ $reduce_expr, $initial_expr ]
						needs_unbox : False
					}
					code_value : codegen.bind {
						define : {
							new_outer_frame : kws.frame_new {
								creation_method : pretty_name
								container : parameters.self_frame
								context : parameters.context
							}
						}
						returns : new_parameters.new_outer_frame
						in : Template fricassee_iterator {
							accumulator_type : type.any
							start : Template codegen.other_code {
								field : $initial_expr
							}
							step : Template codegen.bind {
								define : {
									current_itr_frame : kws.dynamic_type_dispatch {
										of : parameters.current_itr_frame
										allow_types : [ type.frame ]
									}
									new_inner_frame : kws.set_frame_or_tmpl {
										returns : with
										name : current_name
										into : parameters.new_outer_frame
										with : kws.frame_new {
											creation_method : pretty_name
											container : parameters.self_frame
											context : parameters.context
										}
									}
									context : kws.ctxt_prepend {
										frame : kws.dynamic_type_dispatch {
											of : parameters.current_itr_frame
											allow_types : [ type.frame ]
										}
										tail : parameters.context
									}
									real_accumulator : current_accumulator
								}
								in : Template codegen.push_source_reference {
									in : kws.iterator {
										accumulator_type : type.any
										input : input_list {
											items : [ parameters.current_itr_frame ]
										}
										initial : kws.null_constant {}
										default_case : kws.set_frame_or_tmpl {
											returns : current_accumulator
											name : current_name
											into : parameters.new_inner_frame
											with : kws.lookup_dynamic {
												name : current_name
												source : kws.ctxt_prepend {
													frame : parameters.current_itr_frame
													tail : kws.ctxt_null {}
												}
											}
										}
										cases : [
											field_case {
												field : $initial_name
												action : kws.set_frame_or_tmpl {
													returns : with
													name : current_name
													into : parameters.new_inner_frame
													with : codegen.prepare_lookup_cache {
														name : $reduce_env
														specials : special_from_expression {
															type_storage : $bottleneck_type
															field : $initial_name
															is : parameters.real_accumulator
														}
														in : codegen.other_code {
															field : $reduce_expr
														}
													}
												}
											}
										]
									}
								}
							}
						}
					}
				}

				each : Template selector_tmpl {
					level : max_level
					pretty_name : "fricassée Each input"
					pattern : parser.sequence {
						of : [
							space { mandatory : True },
							parser.exact { word : "Each" },
							space { preferred : True },
							parser.other { item_type : $expression  alternate : $expression0 field : $each_expr },
							space { preferred : True }
						]
					}
					apply_environment_to : [
						environment.other_elements { fields : [ $each_expr ] },
						environment.blank_environment {
							name : $blank
							apply_to : [ environment.collect { } ]
						}
					]
					type_demand : ensure_type.frame {
						ensure_type_of : ensure_type.propagate { fields : [ $each_expr ] }
					}
					api_value : apigen.other { fields : [ $each_expr ] }
					code_value : codegen.other_code { field : $each_expr }
				}
				merge : Template selector_tmpl {
					level : max_level
					pretty_name : "fricassée merge input"
					pattern : parser.sequence {
						of : [
							space { mandatory : True },
							parser.accumulate_list {
								field : $inputs
								item_type : $fricassee_merge_input
								in : parser.many_word {
									nonempty : True
									of : parser.other {
										item_type : $fricassee_merge_input
										field : Null
									}
									separator_word : ","
								}
							},
							space { mandatory : True }
						]
					}
					apply_environment_to : [
						environment.list_of { field : $inputs },
						environment.modified_environment {
							name : $merge_environment
							special_names : [ masks_from_definitions { field : $inputs } ]
							apply_to : [ environment.collect { } ]
						}
					]
					api_value : apigen.other_list { field : $inputs }
					code_value : kws.iterator {
						accumulator_type : type.mutable_frame
						input : input_merge { field : $inputs }
						cases : []
						initial : kws.frame_new {
							creation_method : "fricassée merge"
							container : parameters.self_frame
							context : parameters.context
						}
						default_case : kws.set_frame_or_tmpl {
							name : current_name
							into : current_accumulator
							with : input.make_merge_frame
						}
					}
				}
			}
		}
		fricassee_merge_input : Template syntax_group {
			environment_enabled : True
			is_typeable : True
			common +: {
				comment : common_fields.str
				name : common_fields.str
			}
			generation_flavour : codegen.flavour_aware
			merge_input_tmpl : Template syntax_element {
				prepare_value : Required
				needs_generation : False
			}
			# The implementation must provide ways to access the special preparation values.
			prepare_operations : Required
			rules +: {
				expr_input : Template merge_input_tmpl {
					pretty_name : "fricassée frame input"
					needs_generation : True
					pattern : attribute_pattern { }
					apply_environment_to : [ environment.other_elements { fields : [ $expression ] } ]
					ensure_type_is : ensure_type.intrinsic { needs_unbox : True }
					type_demand : ensure_type.frame {
						ensure_type_of : ensure_type.propagate { fields : [ $expression ] }
					}
					api_value : apigen.other { fields : [ $expression ] }
					code_value : codegen.other_code { field : $expression }
					prepare_value : kws.set_frame_or_tmpl {
						name : kws.string_constant_from_field { field : $name }
						into : prepare_operations.target_frame
						with : kws.conditional {
							condition : kws.frame_has {
								name : prepare_operations.name
								source : prepare_operations.matched_frame
							}
							true_action : kws.lookup_dynamic {
								name : prepare_operations.name
								source : kws.ctxt_prepend {
									frame : prepare_operations.matched_frame
									tail : kws.ctxt_null {}
								}
							}
							false_action : kws.null_constant {}
						}
					}
				}
				name_input : Template merge_input_tmpl {
					pretty_name : "fricassée Name input"
					pattern : attribute_pattern {
						value_pattern : Template parser.exact { word : "Name" }
					}
					apply_environment_to : [ ]
					ensure_type_is : ensure_type.filter { types : [ type.str ] }
					api_value : apigen.nop {}
					code_value : codegen.not_implemented {}
					prepare_value : kws.set_frame_or_tmpl {
						name : kws.string_constant_from_field { field : $name }
						into : prepare_operations.target_frame
						with : prepare_operations.name
					}
				}
				ordinal_input : Template merge_input_tmpl {
					pretty_name : "fricassée Ordinal input"
					pattern : attribute_pattern {
						value_pattern : Template parser.exact { word : "Ordinal" }
					}
					apply_environment_to : [ ]
					ensure_type_is : ensure_type.filter { types : [ type.int ] }
					api_value : apigen.nop {}
					code_value : codegen.not_implemented {}
					prepare_value : kws.set_frame_or_tmpl {
						name : kws.string_constant_from_field { field : $name }
						into : prepare_operations.target_frame
						with : prepare_operations.ordinal
					}
				}
			}
		}

		type_name : Template syntax_group {
			type_element : Template syntax_element {
				pattern : parser.exact { word : type_def.name }
				pretty_name : type_def.name & " type"
				api_value : apigen.nop {}
			}
			static_rules :
				For type_def : type, rule_name : Name
					Where type_def.visible
					Select rule_name : type_element {}
		}

		time : Template syntax_group {
			generation_flavour : codegen.flavour_accumulate
			time_chunk : Template syntax_element {
				unit : Required
				symbol : Required
				pattern : int_with_unit_tmpl {}
				api_value : apigen.nop {}
				code_value : kws.int_add {
					left : parameters.accumulator
					right : kws.numeric_constant_units {
						item_type : type.int
						field : $count
					}
				}
			}
			rules +: {
				days : Template time_chunk {
					pretty_name : "days"
					symbol : "d"
					unit : 60 * 60 * 24
				}
				hours : Template time_chunk {
					pretty_name : "hours"
					symbol : "h"
					unit : 60 * 60
				}
				minutes : Template time_chunk {
					pretty_name : "minutes"
					symbol : "m"
					unit : 60
				}
				seconds : Template time_chunk {
					pretty_name : "seconds"
					symbol : "s"
					unit : 1
				}
			}
		}

		string_piece : Template syntax_group {
			environment_enabled : True
			generation_flavour : codegen.flavour_aware_accumulate
			common +: {
				comment : common_fields.str
			}
			string_escape_tmpl : Template parser.collect_codepoint {
				char : Required
				in : parser.exact { word : "\\\\" & char }
			}
			rules +: {
				literal_string : Template syntax_element {
					pretty_name : "string literal"
					pattern : parser.accumulate_string {
						field : $text
						in : parser.many {
							nonempty : True
							of : parser.alternate {
								of : [
									string_escape_tmpl { char : "a"  codepoint : 7 },
									string_escape_tmpl { char : "b"  codepoint : 8 },
									string_escape_tmpl { char : "f"  codepoint : 12 },
									string_escape_tmpl { char : "n" codepoint : 10 },
									string_escape_tmpl { char : "r" codepoint : 13 },
									string_escape_tmpl { char : "t" codepoint : 9 },
									string_escape_tmpl { char : "v"  codepoint : 11 },
									string_escape_tmpl { char : "\\\""  codepoint : 34 },
									string_escape_tmpl { char : "\\\\"  codepoint : 92 },
									parser.accumulate_unichar_integer {
										multiplier : 8
										offset : 48
										in : parser.sequence {
											of : [
												parser.exact { word : "\\\\" },
												parser.range { from : "0"  to : "7"  accumulate : True},
												parser.range { from : "0"  to : "7"  accumulate : True},
												parser.range { from : "0"  to : "7"  accumulate : True}
											]
										}
									},
									parser.accumulate_unichar_integer {
										in : parser.sequence {
											of : [
												parser.exact { word : "\\\\x" },
												hex_digit { },
												hex_digit { }
											]
										}
									},
									parser.accumulate_unichar_integer {
										in : parser.sequence {
											of : [
												parser.exact { word : "\\\\u" },
												hex_digit { },
												hex_digit { },
												hex_digit { },
												hex_digit { }
											]
										}
									},
									parser.accumulate_unichar_integer {
										in : parser.sequence {
											of : [
												parser.exact { word : "\\\\U" },
												hex_digit { },
												hex_digit { },
												hex_digit { },
												hex_digit { },

												hex_digit { },
												hex_digit { },
												hex_digit { },
												hex_digit { }
											]
										}
									},
									parser.single {
										char : "\\\\\\\""
										invert_match : True
										accumulate : True
									}
								]
							}
						}
					}
					apply_environment_to : [ ]
					api_value : apigen.nop {}
					code_value : kws.string_concatenate {
						first : parameters.accumulator
						second : kws.string_constant_from_field { field : $text }
					}
				}
				expression_escape : Template syntax_element {
					pretty_name : "expression in string"
					pattern : parser.sequence {
						of : [
							parser.exact { word : "\\\\(" },
							space { },
							parser.other {
								item_type : $expression
								alternate : $expression0
								field : $expression
							},
							space { },
							parser.exact { word : ")" }
						]
					}
					apply_environment_to : [ environment.other_elements { fields : [ $expression ] } ]
					type_demand : ensure_type.filter {
						needs_unbox : False
						types : [ type.bool, type.float, type.int, type.str ]
						ensure_type_of : ensure_type.propagate { fields : [ $expression ] }
					}
					api_value : apigen.other { fields : [ $expression ] }
					code_value : kws.string_concatenate {
						first : parameters.accumulator
						second : kws.cast_to_string {
							source : codegen.other_code { field : $expression }
						}
					}
				}
			}
		}

		identifier : Template syntax_group {
			common +: {
				comment : common_fields.str
			}
			rules +: {
				literal_identifier : Template syntax_element {
					pretty_name : "identifier"
					pattern : parser.sequence {
						of : [
							space { },
							valid_identifier { field : $name }
						]
					}
					api_value : apigen.nop {}
				}
			}
		}

		arithmetic_disjunction_term : Template syntax_group {
			level : 11
			environment_enabled : True
			is_typeable : True
			generation_flavour : codegen.flavour_aware_accumulate
			common +: {
				comment : common_fields.str
			}
			rules +: {
				addition_term : Template long_term_tmpl {
					pretty_name : "addition term"
					symbol : "+"
					integer_operation : kws.int_add
					float_operation : kws.float_add
				}
				subtraction_term : Template long_term_tmpl {
					pretty_name : "subtraction term"
					symbol : "-"
					integer_operation : kws.int_subtract
					float_operation : kws.float_subtract
				}
			}
		}

		arithmetic_conjunction_term : Template syntax_group {
			level : 12
			environment_enabled : True
			is_typeable : True
			generation_flavour : codegen.flavour_aware_accumulate
			common +: {
				comment : common_fields.str
			}
			rules +: {
				multiplication_term : Template long_term_tmpl {
					pretty_name : "multiplication term"
					symbol : "*"
					integer_operation : kws.int_multiply
					float_operation : kws.float_multiply
				}
				division_term : Template long_term_tmpl {
					pretty_name : "division term"
					symbol : "/"
					integer_operation : kws.int_divide
					float_operation : kws.float_divide
				}
				modulus_term : Template long_term_tmpl {
					pretty_name : "remainder term"
					symbol : "%"
					integer_operation : kws.int_modulus
					float_operation : kws.float_modulus
				}
			}
		}

		expression : Template nested_syntax_group {
			include_base_parser : False
			is_typeable : True
			environment_enabled : True

			generation_flavour : codegen.flavour_aware

			common +: {
				comment : common_fields.str
			}
			max_level : 22
			rules +: {
				let : Template expression_tmpl {
					pretty_name : "name binding"
					level : 0
					pattern : parser.sequence {
						of : [
							parser.exact { word : "Let" },
							space { mandatory : True },
							parser.accumulate_list {
								item_type : $named_definition
								field : $definitions
								deduplicate : expanded_groups.named_definition.expanded_common.name
								in : parser.many_word {
									of : parser.other { item_type : $named_definition  field : Null }
									separator_word : ","
									nonempty : True
								}
							},
							space { mandatory : True },
							parser.exact { word : "In" },
							space { mandatory : True },
							sibling_expression { field : $expression }
						]
					}
					apply_environment_to : [
						environment.list_of { field : $definitions },
						environment.modified_environment {
							force_back : True
							special_names : [ masks_from_definitions { field : $definitions } ]
							apply_to : [ environment.other_elements { fields : [ $expression ] } ]
							name : $inner_environment
						}
					]
					ensure_type_is : ensure_type.propagate {
						fields : [ $expression ]
						needs_unbox : False
					}
					type_demand : ensure_type.propagate_all {
						field : $definitions
					}
					api_value : apigen.many {
						actions : [
							apigen.other { fields : [ $expression ] },
							apigen.other_list { field : $definitions }
						]
					}
					code_value : codegen.prepare_lookup_cache {
						in : codegen.other_code { field : $expression }
						name : $inner_environment
						specials : specials_from_definitions { field : $definitions }
					}
				}

				for_select_anonymous : Template expression_tmpl {
					pretty_name : "fricassée Select"
					level : 1
					pattern : parser.sequence {
						of : [
							parser.exact { word : "For" },
							parser.other { item_type : $selector  alternate : $selector0  field : $selector },
							parser.exact { word : "Select" },
							space { preferred : True },
							parser.other { item_type : $expression  alternate : $expression2  field : $expression },
							space { },
							parser.except { char : ":" }
						]
					}
					apply_environment_to : [
						environment.other_with_result {
							field : $selector
							name : $select_env
							apply_to : [
								environment.other_elements { fields : [ $expression ] }
							]
						}
					]
					ensure_type_is : ensure_type.frame { }
					type_demand : ensure_type.propagate {
						fields : [ $expression ]
						needs_unbox : False
					}
					api_value : apigen.other { fields : [ $selector, $expression ] }
					code_value : fricassee_iterator {
						start : Template kws.frame_new {
							creation_method : pretty_name
							container : parameters.self_frame
							context : parameters.context
						}
						step : Template kws.set_frame_or_tmpl {
							returns : into

							name : kws.string_ordinal {
								source : current_ordinal
							}
							into : current_accumulator
							with : codegen.push_source_reference {
								syntax : $expression
								in : codegen.other_code { field : $expression }
							}
						}
					}
				}
				for_select_named : Template expression_tmpl {
					pretty_name : "fricassée Select with attribute names"
					level : 1
					pattern : parser.sequence {
						of : [
							parser.exact { word : "For" },
							parser.other { item_type : $selector  alternate : $selector1  field : $selector },
							parser.exact { word : "Select" },
							space { preferred : True },
							parser.other { item_type : $expression  alternate : $expression0 field : $name_expr },
							space { preferred : True },
							parser.exact { word : ":" },
							space { preferred : True },
							parser.other { item_type : $expression  alternate : $expression2 field : $value_expr }
						]
					}
					apply_environment_to : [
						environment.other_with_result {
							field : $selector
							name : $select_env
							apply_to : [
								environment.other_elements { fields : [ $name_expr, $value_expr ] }
							]
						}
					]
					ensure_type_is : ensure_type.frame { }
					type_demand : ensure_type.multiple {
						actions : [
							ensure_type.filter {
								types : [ type.int, type.str ]
								ensure_type_of : ensure_type.propagate {
									fields : [ $name_expr ]
								}
							},
							ensure_type.propagate {
								fields : [ $value_expr ]
								needs_unbox : False
							}
						]
					}
					api_value : apigen.other { fields : [ $selector, $name_expr, $value_expr ] }
					code_value : fricassee_iterator {
						start : Template kws.frame_new {
							creation_method : pretty_name
							container : parameters.self_frame
							context : parameters.context
						}
						step : Template kws.set_frame_or_tmpl {
							returns : into

							name : codegen.bind {
								define : {
									attr_name : codegen.type_dispatch {
										of : codegen.push_source_reference {
											syntax : $name_expr
											in : codegen.other_code { field : $name_expr }
										}
										choices : [
											choice_tmpl {
												item_type : type.int
												action : kws.string_ordinal {
													source : converted_result
												}
											},
											choice_tmpl {
												item_type : type.str
												action : kws.conditional {
													condition : kws.verify_symbol {
														source : converted_result
													}
													true_action : converted_result
													false_action : codegen.die { }
												}
											}
										]
									}
								}
								in : Template kws.conditional {
									condition : kws.frame_has {
										source : current_accumulator
										name : parameters.attr_name
									}
									false_action : parameters.attr_name
									true_action : kws.error {
										message : kws.string_concatenate {
											first : kws.string_constant { str : "Duplicate attribute name: " }
											second : parameters.attr_name
										}
									}
								}
							}
							into : current_accumulator
							with : codegen.push_source_reference {
								syntax : $value_expr
								in : codegen.other_code { field : $value_expr }
							}
						}
					}
				}
				for_reduce : Template expression_tmpl {
					pretty_name : "fricassée Reduce"
					level : 1
					pattern : parser.sequence {
						of : [
							parser.exact { word : "For" },
							parser.other { item_type : $selector  alternate : $selector0  field : $selector },
							parser.exact { word : "Reduce" },
							space { mandatory : True },
							parser.other { item_type : $expression  alternate : $expression0  field : $reduce_expr },
							space { mandatory : True },
							parser.exact { word : "With" },
							space { mandatory : True },
							valid_identifier { field : $initial_name },
							space { preferred : True },
							parser.exact { word : ":" },
							space { preferred : True },
							parser.other { item_type : $expression  alternate : $expression2  field : $initial_expr }
						]
					}
					apply_environment_to : [
						environment.other_elements {
							fields : [ $initial_expr ]
						},
						environment.other_with_result {
							field : $selector
							name : $select_env
							apply_to : [
								environment.modified_environment {
									name : $reduce_env
									special_names : [ mask_from_fields {
										name_field : $initial_name
										expr_field : $initial_expr
										type_storage : $bottleneck_type
									} ]
									apply_to : [
										environment.other_elements { fields : [ $reduce_expr ] }
									]
								}
							]
						}
					]
					ensure_type_is : ensure_type.multiple {
						needs_unbox : False
						actions : [
							ensure_type.propagate { fields : [ $reduce_expr, $initial_expr ] },
							ensure_type.special {
								type_storage : $bottleneck_type
							}
						]
					}
					api_value : apigen.other { fields : [ $selector, $reduce_expr, $initial_expr ] }
					code_value : kws.dynamic_type_dispatch_from_stored_mask {
						type_storage : $bottleneck_type
						of : fricassee_iterator {
							accumulator_type : type.any
							start : Template codegen.other_code { field : $initial_expr }
							step : Template codegen.prepare_lookup_cache {
								name : $reduce_env
								specials : special_from_expression {
									type_storage : $bottleneck_type
									field : $initial_name
									is : current_accumulator
								}
								in : codegen.other_code { field : $reduce_expr }
							}
						}
					}
				}

				if : Template expression_tmpl {
					pretty_name : "conditional expression"
					level : 2
					pattern : parser.sequence {
						of : [
							parser.exact { word : "If" },
							space { mandatory : True },
							top_expression { field : $cond_expr },
							space { mandatory : True },
							parser.exact { word : "Then" },
							space { mandatory : True },
							top_expression { field : $then_expr },
							space { mandatory : True },
							parser.exact { word : "Else" },
							space { mandatory : True },
							sibling_expression { field : $else_expr }
						]
					}
					apply_environment_to : [
						environment.other_elements { fields : [ $cond_expr ] },
						environment.modified_environment {
							apply_to : [ environment.other_elements { fields : [ $then_expr ] } ]
							name : $then_environment
						},
						environment.modified_environment {
							apply_to : [ environment.other_elements { fields : [ $else_expr ] } ]
							name : $else_environment
						}
					]
					ensure_type_is : ensure_type.propagate {
						needs_unbox : False
						fields : [ $then_expr, $else_expr ]
					}
					type_demand : ensure_type.bool {
						ensure_type_of : ensure_type.propagate { fields : [ $cond_expr ] }
					}
					api_value : apigen.other { fields : [ $cond_expr, $then_expr, $else_expr ] }
					code_value : kws.conditional {
						condition : codegen.other_code { field : $cond_expr }
						true_action : codegen.prepare_lookup_cache {
							in : codegen.other_code { field : $then_expr }
							name : $then_environment
						}
						false_action : codegen.prepare_lookup_cache {
							in : codegen.other_code { field : $else_expr }
							name : $else_environment
						}
					}
				}

				concatenate : Template binary_operator {
					pretty_name : "string concatenation"
					level : 3
					operator : "&"
					right_operand : Template sibling_expression {}
					ensure_type_is : ensure_type.filter { types : [ type.str ] }
					type_demand : ensure_type.filter {
						types : [ type.bool, type.float, type.int, type.str ]
						needs_unbox : False
						ensure_type_of : ensure_type.propagate { fields : [ $left, $right ] }
					}
					code_value : kws.string_concatenate {
						first : kws.cast_to_string {
							source : codegen.other_code { field : $left }
						}
						second : kws.cast_to_string {
							source : codegen.other_code { field : $right }
						}
					}
				}
				list_join : Template binary_operator {
					pretty_name : "frame concatenation"
					level : 3
					operator : "Append"
					right_operand : Template sibling_expression {}
					ensure_type_is : ensure_type.filter {
						types : [ type.frame ]
						ensure_type_of : ensure_type.propagate { fields : [ $left, $right ] }
					}
					code_value : codegen.bind {
						define : {
							output_frame : kws.frame_new {
								creation_method : "concatenated"
								container : parameters.self_frame
								context : parameters.context
							}
							left_input : codegen.other_code { field : $left }
							right_input : codegen.other_code { field : $right }
						}
						in : Template codegen.bind {
							define : {
								offset : kws.iterator {
									accumulator_type : type.int
									input : input_list { items : [ parameters.left_input ] }
									initial : kws.numeric_constant {
										item_type : type.int
										number : 0
									}
									default_case : kws.set_frame_or_tmpl {
										name : kws.string_ordinal {
											source : current_ordinal
										}
										returns : current_ordinal
										into : parameters.output_frame
										with : kws.lookup_dynamic {
											name : current_name
											source : kws.ctxt_prepend {
												frame : parameters.left_input
												tail : kws.ctxt_null {}
											}
										}
									}
									cases : []
								}
							}
							in : Template kws.iterator {
								accumulator_type : type.mutable_frame
								input : input_list { items : [ parameters.right_input ] }
								initial : parameters.output_frame
								default_case : kws.set_frame_or_tmpl {
									name : kws.string_ordinal {
										source : kws.int_add {
											left : current_ordinal
											right : parameters.offset
										}
									}
									into : parameters.output_frame
									with : kws.lookup_dynamic {
										name : current_name
										source : kws.ctxt_prepend {
											frame : parameters.right_input
											tail : kws.ctxt_null {}
										}
									}
								}
								cases : []
							}
						}
					}
				}

				disjunction : Template binary_operator {
					pretty_name : "logical disjunction"
					level : 4
					operator : "||"
					right_operand : Template sibling_expression {}
					apply_environment_to : [
						environment.other_elements { fields : [ $left ] },
						environment.modified_environment {
							apply_to : [ environment.other_elements { fields : [ $right ] } ]
							name : $optional_environment
						}
					]
					ensure_type_is : ensure_type.bool {}
					type_demand : ensure_type.bool {
						ensure_type_of : ensure_type.propagate { fields : [ $left, $right ] }
					}
					code_value : kws.conditional {
						condition : codegen.other_code { field : $left }
						true_action : kws.numeric_constant {
							item_type : type.bool
							number : max
						}
						false_action : codegen.prepare_lookup_cache {
							in : codegen.other_code { field : $right }
							name : $optional_environment
						}
					}
				}

				conjunction : Template binary_operator {
					pretty_name : "logical conjunction"
					level : 5
					operator : "&&"
					right_operand : Template sibling_expression {}
					apply_environment_to : [
						environment.other_elements { fields : [ $left ] },
						environment.modified_environment {
							apply_to : [ environment.other_elements { fields : [ $right ] } ]
							name : $optional_environment
						}
					]
					ensure_type_is : ensure_type.bool {}
					type_demand : ensure_type.bool {
						ensure_type_of : ensure_type.propagate { fields : [ $left, $right ] }
					}
					code_value : kws.conditional {
						condition : codegen.other_code { field : $left }
						true_action : codegen.prepare_lookup_cache {
							in : codegen.other_code { field : $right }
							name : $optional_environment
						}
						false_action : kws.numeric_constant {
							item_type : type.bool
							number : min
						}
					}
				}

				equality : Template compare_operator {
					pretty_name : "equality comparison"
					level : 6
					operator : "=="
					number : 0
					invert : False
				}
				inequality : Template compare_operator {
					pretty_name : "inequality comparison"
					level : 6
					operator : "!="
					number : 0
					invert : True
				}
				greater : Template compare_operator {
					pretty_name : "greater-than comparison"
					level : 6
					operator : ">"
					number : 1
					invert : False
				}
				greater_or_equality : Template compare_operator {
					pretty_name : "greater-than or equality comparison"
					level : 6
					operator : ">="
					number : -1
					invert : True
				}
				lesser : Template compare_operator {
					pretty_name : "lesser-than comparison"
					level : 6
					operator : "<"
					number : -1
					invert : False
				}
				lesser_or_equality : Template compare_operator {
					pretty_name : "lesser-than or equality comparison"
					level : 6
					operator : "<="
					number : 1
					invert : True
				}

				compare : Template binary_operator {
					pretty_name : "comparison"
					level : 7
					operator : "<=>"
					type_demand : ensure_type.filter {
						types : [ type.bool, type.float, type.int, type.str ]
						ensure_type_of : ensure_type.shared_fate {
							ensure_type_of : ensure_type.propagate { fields : [ $left, $right ] }
						}
					}
					ensure_type_is : ensure_type.filter { types : [ type.int ] }
					code_value : kws.compare {
						left : codegen.other_code { field : $left }
						right : codegen.other_code { field : $right }
					}
				}

				bitwise_disjunction : Template binary_operator {
					pretty_name : "bit-wise disjunction"
					level : 8
					operator : "B|"
					right_operand : Template sibling_expression {}
					apply_environment_to : [
						environment.other_elements { fields : [ $left, $right ] }
					]
					ensure_type_is : ensure_type.int {
						ensure_type_of : ensure_type.propagate { fields : [ $left, $right ] }
					}
					code_value : kws.int_or {
						left : codegen.other_code { field : $left }
						right : codegen.other_code { field : $right }
					}
				}

				bitwise_symdiff : Template binary_operator {
					pretty_name : "bit-wise symmetric difference"
					level : 9
					operator : "B^"
					right_operand : Template sibling_expression {}
					apply_environment_to : [
						environment.other_elements { fields : [ $left, $right ] }
					]
					ensure_type_is : ensure_type.int {
						ensure_type_of : ensure_type.propagate { fields : [ $left, $right ] }
					}
					code_value : kws.int_xor {
						left : codegen.other_code { field : $left }
						right : codegen.other_code { field : $right }
					}
				}

				bitwise_conjunction : Template binary_operator {
					pretty_name : "bit-wise conjunction"
					level : 10
					operator : "B&"
					right_operand : Template sibling_expression {}
					apply_environment_to : [
						environment.other_elements { fields : [ $left, $right ] }
					]
					ensure_type_is : ensure_type.int {
						ensure_type_of : ensure_type.propagate { fields : [ $left, $right ] }
					}
					code_value : kws.int_and {
						left : codegen.other_code { field : $left }
						right : codegen.other_code { field : $right }
					}
				}

				arithmetic_disjunction : Template long_expression_tmpl {
					pretty_name : "arithmetic disjunction"
					level : 11
					term_type : $arithmetic_disjunction_term
				}

				arithmetic_conjunction : Template long_expression_tmpl {
					pretty_name : "arithmetic conjunction"
					level : 12
					term_type : $arithmetic_conjunction_term
				}

				range : Template binary_operator {
					pretty_name : "integral range"
					level : 13
					operator : "Through"
					ensure_type_is : ensure_type.frame { }
					type_demand : ensure_type.filter {
						types : [ type.int ]
						ensure_type_of : ensure_type.propagate { fields : [ $left, $right ] }
					}
					code_value : codegen.push_source_reference {
						in : kws.frame_new_through {
							start : codegen.other_code { field : $left }
							end : codegen.other_code { field : $right }
							container : parameters.self_frame
							context : parameters.context
						}
					}
				}

				coerce : Template type_operator {
					pretty_name : "type coercion"
					level : 14
					operator : "To"
					ensure_type_is : ensure_type.dynamic {
						field : $right
					}
					type_demand : ensure_type.dynamic {
						field : $right
						propagate_castable : True
						ensure_type_of : propagate { fields : [ $left ] }
					}
					code_value : codegen.type_dispatch {
						of : codegen.other_code { field : $left }
						left_result : converted_result
						choices : [
							# Int → *
							choice_tmpl {
								item_type : type.int
								action : codegen.type_dispatch_parsed {
									field : $right
									choices : [
										# Int → Int
										choice_tmpl {
											item_type : type.int
											action : left_result
										},
										# Int → Float
										choice_tmpl {
											item_type : type.float
											action : kws.int_to_float {
												expr : left_result
											}
										},
										# Int → Str
										choice_tmpl {
											item_type : type.str
											action : kws.cast_to_string {
												source : left_result
											}
										}
									]
								}
							},
							# Float → *
							choice_tmpl {
								item_type : type.float
								action : codegen.type_dispatch_parsed {
									field : $right
									choices : [
										# Float → Float
										choice_tmpl {
											item_type : type.float
											action : left_result
										},
										# Float → Int
										choice_tmpl {
											item_type : type.int
											action : kws.float_to_int {
												expr : left_result
											}
										},
										# Float → Str
										choice_tmpl {
											item_type : type.str
											action : kws.cast_to_string {
												source : left_result
											}
										}
									]
								}
							},
							# Bool → *
							choice_tmpl {
								item_type : type.bool
								action : codegen.type_dispatch_parsed {
									field : $right
									choices : [
										# Bool → Bool
										choice_tmpl {
											item_type : type.bool
											action : left_result
										},
										# Bool → Str
										choice_tmpl {
											item_type : type.str
											action : kws.cast_to_string {
												source : left_result
											}
										}
									]
								}
							},
							# Frame → *
							choice_tmpl {
								item_type : type.frame
								action : codegen.type_dispatch_parsed {
									field : $right
									choices : [
										choice_tmpl {
											item_type : type.frame
											action : left_result
										}
									]
								}
							},
							# Null → *
							choice_tmpl {
								item_type : type.null
								action : codegen.type_dispatch_parsed {
									field : $right
									choices : [
										choice_tmpl {
											item_type : type.null
											action : left_result
										}
									]
								}
							},
							# Template → *
							choice_tmpl {
								item_type : type.template
								action : codegen.type_dispatch_parsed {
									field : $right
									choices : [
										choice_tmpl {
											item_type : type.template
											action : left_result
										}
									]
								}
							},
							# Str → *
							choice_tmpl {
								item_type : type.str
								action : codegen.type_dispatch_parsed {
									field : $right
									choices : [
										choice_tmpl {
											item_type : type.str
											action : left_result
										}
									]
								}
							},
							# Any → *
							choice_tmpl {
								item_type : type.any
								action : codegen.type_dispatch_parsed {
									field : $right
									choices : [
										choice_tmpl {
											item_type : type.str
											action : kws.cast_to_string {
												source : left_result
											}
										}
									]
								}
							}
						]
					}
				}
				enforce : Template type_operator {
					pretty_name : "type enforcement"
					level : 14
					operator : "Enforce"
					ensure_type_is : ensure_type.dynamic {
						field : $right
						ensure_type_of : ensure_type.propagate { fields : [ $left ] }
					}
					# This is here because we slightly tell lies. Normally, type
					# propagation has ensure that the value of the left expression is of
					# the correct type. However, for numeric operations, the operation
					# can be always include integers. Normally, the downstream operation
					# does not care whether the result is an integer or floating point
					# number, but in this rare scenario, it does. Therefore, if the
					# result is an integer, upgrade it to a float.
					code_value : codegen.type_dispatch_parsed {
						field : $right
						choices : [
							choice_tmpl {
								item_type : type.float
								action : codegen.type_dispatch {
									of : codegen.other_code { field : $left }
									allow_types : [ type.float, type.int ]
									choices : [
										choice_tmpl {
											item_type : type.int
											action : kws.int_to_float {
												expr : converted_result
											}
										}
									]
									default_action : converted_result
								}
							}
						]
						default_action : codegen.other_code { field : $left }
					}
				}
				check : Template type_operator {
					pretty_name : "type check"
					level : 14
					operator : "Is"
					ensure_type_is : ensure_type.bool {}
					type_demand : ensure_type.propagate {
						needs_unbox : False
						fields : [ $left ]
					}
					code_value : codegen.type_dispatch_parsed {
						field : $right

						choices :
							For t : type
								Where t.visible
								Select choice_tmpl {
									item_type : t
									action : codegen.type_dispatch {
										of : codegen.other_code { field : $left }
										default_action : kws.numeric_constant { item_type : type.bool  number : min }
										choices : [
											choice_tmpl {
												item_type : t
												action : kws.numeric_constant { item_type : type.bool  number : max }
											},
											choice_tmpl {
												item_type : type.any
												action : kws.dynamic_type_check {
													item_type : t
													source : converted_result
												}
											}
										]
									}
								}
					}
				}
				is_finite : Template is_suffix_operator {
					pretty_name : "finite check"
					level : 14
					suffix : "Finite"
					ensure_type_is : ensure_type.bool {}
					type_demand : ensure_type.number {
						ensure_type_of : ensure_type.propagate { fields : [ $left ] }
					}
					code_value : codegen.type_dispatch {
						of : codegen.other_code { field : $left }
						left_result : converted_result
						choices : [
							choice_tmpl {
								item_type : type.int
								action : kws.numeric_constant {
									item_type : type.bool
									number : max
								}
							},
							choice_tmpl {
								item_type : type.float
								action : kws.float_is_finite {
									source : left_result
								}
							}
						]
					}
				}
				is_nan : Template is_suffix_operator {
					pretty_name : "not-a-number check"
					level : 14
					suffix : "NaN"
					ensure_type_is : ensure_type.bool {}
					type_demand : ensure_type.number {
						ensure_type_of : ensure_type.propagate { fields : [ $left ] }
					}
					code_value : codegen.type_dispatch {
						of : codegen.other_code { field : $left }
						left_result : converted_result
						choices : [
							choice_tmpl {
								item_type : type.int
								action : kws.numeric_constant {
									item_type : type.bool
									number : min
								}
							},
							choice_tmpl {
								item_type : type.float
								action : kws.float_is_nan {
									source : left_result
								}
							}
						]
					}
				}
				is_null : Template is_suffix_operator {
					pretty_name : "null check"
					level : 14
					suffix : "Null"
					ensure_type_is : ensure_type.bool {}
					type_demand : ensure_type.propagate {
						fields : [ $left ]
					}
					code_value : codegen.type_dispatch {
						of : codegen.other_code { field : $left }
						default_action : kws.numeric_constant {
							item_type : type.bool
							number : min
						}
						choices : [
							choice_tmpl {
								item_type : type.null
								action : kws.numeric_constant {
									item_type : type.bool
									number : max
								}
							}
						]
					}
				}

				error : Template unary_tmpl {
					pretty_name : "raise error"
					level : 15
					operator : "Error"
					ensure_type_is : ensure_type.stop {}
					type_demand : ensure_type.filter {
						types : [ type.bool, type.float, type.int, type.str ]
						needs_unbox : False
						ensure_type_of : ensure_type.propagate { fields : [ $expr ] }
					}
					code_value : kws.error {
						message : kws.cast_to_string {
							source : codegen.other_code { field : $expr }
						}
					}
				}
				length : Template unary_tmpl {
					pretty_name : "length"
					level : 15
					operator : "Length"
					ensure_type_is : ensure_type.stop {}
					type_demand : ensure_type.filter {
						types : [ type.bin, type.bool, type.float, type.int, type.str ]
						needs_unbox : False
						ensure_type_of : ensure_type.propagate { fields : [ $expr ] }
					}
					code_value : codegen.type_dispatch {
						of : codegen.other_code { field : $expr }
						default_action : kws.string_length {
							source : kws.cast_to_string {
								source : converted_result
							}
						}

						choices : [
							choice_tmpl {
								item_type : type.bin
								action : kws.binary_length {
									source : converted_result
								}
							}
						]
					}
				}

				remote_lookup : Template expression_tmpl {
					pretty_name : "remote contextual lookup"
					level : 16
					pattern : parser.sequence {
						of : [
							parser.exact { word : "Lookup" },
							space { mandatory : True },
							parser.accumulate_list {
								item_type : $identifier
								field : $names
								in : parser.many_word {
									of : parser.other {
										item_type : $identifier
										field : Null
									}
									separator_word : "."
								}
							},
							space { mandatory : True },
							parser.exact { word : "In" },
							space { mandatory : True },
							sibling_expression { field : $expression }
						]
					}
					apply_environment_to : [ environment.other_elements { fields : [ $expression ] } ]
					ensure_type_is : ensure_type.intrinsic { needs_unbox : False }
					type_demand : ensure_type.frame {
						ensure_type_of : ensure_type.propagate { fields : [ $expression ] }
					}
					api_value : apigen.other { fields : [ $expression ] }
					code_value : codegen.return_intrinsic_dispatch {
						of : kws.lookup_field {
							field : $names
							source : kws.frame_context {
								source : codegen.other_code { field : $expression }
							}
						}
					}
				}

				instantiation : Template expression_tmpl {
					pretty_name : "template instantiation"
					level : 17
					pattern : parser.sequence {
						of : [
							child_expression { field : $source },
							space { preferred : True },
							parser.exact { word : "{" },
							parser.accumulate_list {
								field : $overrides
								item_type : $attribute
								deduplicate : expanded_groups.attribute.expanded_common.name
								in : parser.many {
									of : parser.sequence {
										of : [
											pure_space {},
											parser.other {
												item_type : $attribute
												field : Null
												alternate : $instantiate_tmpl_attributes
											}
										]
									}
								}
							},
							space { preferred : True },
							parser.exact { word : "}" }
						]
					}
					apply_environment_to : [
						environment.other_elements { fields : [ $source ] },
						environment.list_independent { field : $overrides }
					]
					ensure_type_is : ensure_type.frame {}
					type_demand : ensure_type.filter {
						types : [ type.template ]
						ensure_type_of : ensure_type.propagate { fields : [ $source ] }
					}
					api_value : apigen.many {
						actions : [
							apigen.other { fields : [ $source ] },
							apigen.other_list {
								field : $overrides
								collect_names : True
							}
						]
					}
					code_value : perform_overrides {
						accumulator_type : type.mutable_frame
						new_item : Template kws.frame_new {
							creation_method : "instantiated"
							container : parameters.self_frame
						}
						source_template : codegen.other_code { field : $source }
					}
				}

				coalesce : Template binary_operator {
					pretty_name : "null coalescence"
					level : 18
					operator : "??"
					apply_environment_to : [
						environment.other_elements { fields : [ $left ] },
						environment.modified_environment {
							apply_to : [ environment.other_elements { fields : [ $right ] } ]
							name : $optional_environment
						}
					]
					ensure_type_is : ensure_type.multiple {
						actions : [
							ensure_type.propagate { fields : [ $right ] },
							ensure_type.propagate {
								extra_types : [ type.null ]
								fields : [ $left ]
							}
						]
					}
					code_value : codegen.type_dispatch {
						of : codegen.other_code { field : $left }
						default_action : converted_result
						choices : [
							choice_tmpl {
								item_type : type.null
								action : codegen.prepare_lookup_cache {
									name : $optional_environment
									in : codegen.other_code { field : $right }
								}
							}
						]
					}
				}

				nullable_lookup : Template expression_tmpl {
					pretty_name : "nullable contextual lookup"
					level : 19
					pattern : parser.sequence {
						of : [
							child_expression { field : $expression },
							parser.exact { word : "?." },
							parser.accumulate_list {
								item_type : $identifier
								field : $names
								nonempty : True
								in : parser.many_word {
									of : parser.other {
										item_type : $identifier
										field : Null
									}
									separator_word : "."
								}
							}
						]
					}
					apply_environment_to : [ environment.other_elements { fields : [ $expression ] } ]
					ensure_type_is : ensure_type.multiple {
						actions : [
							ensure_type.intrinsic { needs_unbox : False },
							ensure_type.filter { types : [ type.null ] }
						]
					}
					type_demand : ensure_type.filter {
						types : [ type.frame, type.null ]
						ensure_type_of : ensure_type.propagate { fields : [ $expression ] }
					}
					api_value : apigen.other { fields : [ $expression ] }
					code_value : codegen.type_dispatch {
						of : codegen.other_code { field : $expression }
						choices : [
							choice_tmpl {
								item_type : type.null
								action : kws.null_constant {}
							},
							choice_tmpl {
								item_type : type.frame
								action : codegen.return_intrinsic_dispatch {
									of : kws.lookup_field {
										field : $names
										source : kws.frame_context {
											source : converted_result
										}
									}
								}
							}
						]
					}
				}
				literal_frame : Template expression_tmpl {
					pretty_name : "literal frame"
					level : 19
					pattern : parser.sequence {
						of : [
							parser.exact { word : "{" },
							space { preferred : True },
							parser.accumulate_list {
								field : $attributes
								item_type : $attribute
								deduplicate : expanded_groups.attribute.expanded_common.name
								in : parser.many {
									of : parser.sequence {
										of : [
											pure_space {},
											parser.other {
												item_type : $attribute
												field : Null
												alternate : $plain_attribute
											}
										]
									}
								}
							},
							space { preferred : True },
							parser.exact { word : "}" }
						]
					}
					apply_environment_to : [ environment.list_independent { field : $attributes } ]
					ensure_type_is : ensure_type.frame {}
					api_value : apigen.other_list {
						field : $attributes
						collect_names : True
					}
					code_value : codegen.push_source_reference {
						in : codegen.empty_parameter {
							parameters : { source_template : emptiness }
							in : codegen.collapse_others {
								item_type : type.mutable_frame
								target_flavour : codegen.flavour_attribute_accumulate
								field : $attributes
								initial : kws.frame_new {
									container : parameters.self_frame
									context : parameters.context
								}
							}
						}
					}
				}
				type_of : Template expression_tmpl {
					pretty_name : "type-directed lookup"
					level : 19
					pattern : parser.sequence {
						of : [
							parser.exact { word : "TypeOf" },
							space { mandatory : True },
							child_expression { field : $expression },
							parser.optional {
								of : parser.sequence {
									of : [
										space { mandatory : True },
										parser.exact { word : "With" },
										parser.accumulate_list {
											item_type : $identifier
											field : $names
											in : parser.many_word {
												of : parser.other {
													item_type : $identifier
													field : Null
												}
												separator_word : "."
											}
										}
									]
								}
							}
						]
					}
					apply_environment_to : [ environment.other_elements { fields : [ $expression ] } ]
					ensure_type_is : ensure_type.intrinsic { needs_unbox : False }
					type_demand : ensure_type.propagate { fields : [ $expression ] }
					api_value : apigen.many {
						actions : [
							apigen.add_name {
								field : $names
								suffixes : For t : type, name : Name Where t.visible Select name
							},
							apigen.other { fields : [ $expression ] }
						]
					}
					code_value : codegen.return_intrinsic_dispatch {
						of : codegen.type_dispatch {
							of : codegen.other_code { field : $expression }
							choice_tmpl +: {
								action : kws.lookup_prefixed {
									prefix_field : $names
									suffix_name : name
									source : parameters.context
								}
							}
							choices : For t : type, name : Name Where t.visible Select choice_tmpl { item_type : t }
						}
					}
				}
				not : Template unary_tmpl {
					pretty_name : "logical negation"
					level : 19
					operator : "!"
					ensure_type_is : ensure_type.bool { ensure_type_of : propagate { fields : [ $expr ] } }
					code_value : kws.bool_negate {
						source : codegen.other_code { field : $expr }
					}
				}
				bitwise_not : Template unary_tmpl {
					pretty_name : "bit-wise complementation"
					level : 19
					operator : "B!"
					ensure_type_is : ensure_type.int { ensure_type_of : propagate { fields : [ $expr ] } }
					code_value : kws.int_complement {
						source : codegen.other_code { field : $expr }
					}
				}
				negation : Template unary_tmpl {
					pretty_name : "numeric negation"
					level : 19
					operator : "-"
					ensure_type_is : ensure_type.number { ensure_type_of : propagate { fields : [ $expr ] } }
					code_value : codegen.type_dispatch {
						of : codegen.other_code { field : $expr }
						choices : [
							choice_tmpl {
								item_type : type.int
								action : kws.int_negate {
									source : converted_result
								}
							},
							choice_tmpl {
								item_type : type.float
								action : kws.float_negate {
									source : converted_result
								}
							}
						]
					}
				}
				generate_id : Template unary_tmpl {
					pretty_name : "unique frame identifier"
					level : 19
					operator : "GenerateId"
					ensure_type_is : ensure_type.filter { types : [ type.str ] }
					type_demand : ensure_type.frame {
						ensure_type_of : ensure_type.propagate { fields : [ $expr ] }
					}
					code_value : kws.frame_id {
						source : codegen.other_code { field : $expr }
					}
				}
				template_new : Template expression_tmpl {
					pretty_name : "define new template"
					level : 19
					pattern : parser.sequence {
						of : [
							parser.exact { word : "Template" },
							space { preferred : True },
							parser.exact { word : "{" },
							parser.accumulate_list {
								field : $attributes
								item_type : $attribute
								deduplicate : expanded_groups.attribute.expanded_common.name
								in : parser.many {
									of : parser.sequence {
										of : [
											pure_space {},
											parser.other {
												item_type : $attribute
												field : Null
												alternate : $new_tmpl_attributes
											}
										]
									}
								}
							},
							space { preferred : True },
							parser.exact { word : "}" }
						]
					}
					apply_environment_to : [ environment.list_independent { field : $attributes } ]
					ensure_type_is : ensure_type.filter { types : [ type.template ] }
					api_value : apigen.other_list {
						field : $attributes
						collect_names : True
					}
					code_value : codegen.empty_parameter {
						parameters : { source_template : emptiness }
						in : codegen.collapse_others {
							item_type : type.template
							target_flavour : codegen.flavour_attribute_accumulate
							field : $attributes
							initial : kws.tmpl_new {
								context : parameters.context
							}
						}
					}
				}
				template_extend : Template expression_tmpl {
					pretty_name : "extend existing template"
					level : 19
					pattern : parser.sequence {
						of : [
							parser.exact { word : "Template" },
							space { mandatory : True },
							child_expression { field : $source },
							space { preferred : True },
							parser.exact { word : "{" },
								parser.accumulate_list {
								field : $overrides
								item_type : $attribute
								deduplicate : expanded_groups.attribute.expanded_common.name
								in : parser.many {
									of : parser.sequence {
										of : [
											pure_space {},
											parser.other {
												item_type : $attribute
												field : Null
												alternate : $extend_tmpl_attributes
											}
										]
									}
								}
							},
							space { preferred : True },
							parser.exact { word : "}" }
						]
					}
					apply_environment_to : [
						environment.other_elements { fields : [ $source ] },
						environment.list_independent { field : $overrides }
					]
					ensure_type_is : ensure_type.filter {
						types : [ type.template ]
						ensure_type_of : propagate { fields : [ $source ] }
					}
					api_value : apigen.many {
						actions : [
							apigen.other { fields : [ $source ] },
							apigen.other_list {
								field : $overrides
								collect_names : True
							}
						]
					}
					code_value : perform_overrides {
						accumulator_type : type.template
						new_item : kws.tmpl_new
						source_template : codegen.other_code { field : $source }
					}
				}
				function_new : Template expression_tmpl {
					pretty_name : "define function-like template"
					level : 19
					pattern : parser.sequence {
						of : [
							parser.exact { word : "Function" },
							space { preferred : True },
							parser.exact { word : "(" },
							parser.accumulate_list {
								field : $attributes
								item_type : $attribute
								deduplicate : expanded_groups.attribute.expanded_common.name
								forbid : [ $value ]
								in : parser.many_word {
									separator_word : ","
									of : parser.sequence {
										of : [
											pure_space {},
											parser.other {
												item_type : $attribute
												field : Null
												alternate : $function_tmpl_attributes
											},
											pure_space {}
										]
									}
								}
							},
							space { },
							parser.exact { word : ")" },
							space { },
							parser.other { item_type : $expression  alternate : $expression0 field : $body }
						]
					}
					apply_environment_to : [
						environment.blank_environment {
							name : $outer_environment
							apply_to : [
								environment.modified_environment {
									name : $inner_environment
									special_names : [
										masks_from_definitions { field : $attributes },
										forbidden_name { name : $value }
									]
									apply_to : [
										environment.list_independent { field : $attributes  inherit : True},
										environment.other_elements { fields : [ $body ] }
									]
								}
							]
						}
					]
					ensure_type_is : ensure_type.filter { types : [ type.template ] }
					type_demand : ensure_type.propagate {
						fields : [ $body ]
						needs_unbox : False
					}
					api_value : apigen.other_list {
						field : $attributes
						collect_names : True
					}
					code_value : codegen.empty_parameter {
						parameters : { source_template : emptiness }
						in : codegen.collapse_others {
							item_type : type.template
							target_flavour : codegen.flavour_attribute_accumulate
							field : $attributes
							initial : kws.set_frame_or_tmpl {
								name : kws.string_constant {
									str : $value
								}
								into : kws.tmpl_new {
									context : parameters.context
								}
								with : kws.create_function {
									returns : codegen.push_source_reference {
										in : codegen.prepare_lookup_cache {
											in : codegen.prepare_lookup_cache {
												in : codegen.other_code { field : $body }
												name : $inner_environment
											}
											name : $outer_environment
										}
									}
								}
							}
						}
					}
				}

				function_anonymous : Template function_tmpl {
					pretty_name : "function-like template instantiation (unnamed arguments)"
					has_anon_args : True
					has_named_args : False
				}
				function_named : Template function_tmpl {
					pretty_name : "function-like template instantiation (named arguments)"
					has_anon_args : False
					has_named_args : True
				}
				function_mixed : Template function_tmpl {
					pretty_name : "function-like template instantiation (named and unnamed arguments)"
					has_anon_args : True
					has_named_args : True
				}

				contextual_lookup : Template expression_tmpl {
					pretty_name : "contextual lookup"
					level : 21
					pattern : parser.accumulate_list {
						field : $parts
						item_type : $identifier
						in : parser.many_word {
							of : parser.other {
								item_type : $identifier
								field : Null
							}
							separator_word : "."
							nonempty : True
						}
					}
					apply_environment_to : []
					ensure_type_is : ensure_type.stored {
						field : $parts
					}
					api_value : apigen.nop {}
					code_value : codegen.lookup_cached { field : $parts }
				}
				from : Template expression_tmpl {
					pretty_name : "external import"
					level : 21
					pattern : parser.sequence {
						of : [
							parser.exact { word : "From" },
							space { mandatory : True },
							uri {}
						]
					}
					apply_environment_to : []
					ensure_type_is : ensure_type.intrinsic { needs_unbox : False }
					api_value : apigen.add_reference { field : $uri }
					code_value : codegen.return_intrinsic_dispatch {
						of : kws.external_from_field {
							field : $uri
						}
					}
				}
				direct_lookup : Template expression_tmpl {
					pretty_name : "direct lookup"
					level : 21
					pattern : parser.sequence {
						of : [
							child_expression { field : $expr },
							space { },
							parser.exact { word : "." },
							parser.accumulate_list {
								item_type : $identifier
								field : $names
								in : parser.many_word {
									of : parser.other {
										item_type : $identifier
										field : Null
									}
									separator_word : "."
									nonempty : True
								}
							}
						]
					}
					apply_environment_to : [ environment.other_elements { fields : [ $expr ] } ]
					ensure_type_is : ensure_type.intrinsic { needs_unbox : False }
					type_demand : ensure_type.frame {
						ensure_type_of : ensure_type.propagate { fields : [ $expr ] }
					}
					api_value : apigen.nop {}
					code_value : codegen.return_intrinsic_dispatch {
						of : kws.lookup_field {
							field : $names
							source : kws.ctxt_prepend {
								frame : codegen.other_code { field : $expr }
								tail : kws.ctxt_null {}
							}
						}
					}
				}

				subexpression : Template expression_tmpl {
					pretty_name : "sub-expression"
					level : max_level
					pattern : parser.sequence {
						of : [
							parser.exact { word : "(" },
							space { },
							top_expression { field : $expression },
							space { },
							parser.exact { word : ")" }
						]
					}
					apply_environment_to : [ environment.other_elements { fields : [ $expression ] } ]
					ensure_type_is : ensure_type.propagate {
						needs_unbox : False
						fields : [ $expression ]
					}
					api_value : apigen.other { fields : [ $expression ] }
					code_value : codegen.other_code { field : $expression }
				}
				literal_list : Template expression_tmpl {
					pretty_name : "literal list"
					level : max_level
					pattern : parser.sequence {
						of : [
							parser.exact { word : "[" },
							parser.accumulate_list {
								field : $items
								item_type : $expression
								in : parser.many_word {
									separator_word : ","
									of : parser.sequence {
										of : [
											space { preferred : True },
											top_expression { field : Null },
											space { }
										]
									}
								}
							},
							space { preferred : True },
							parser.optional {
								of : parser.sequence {
									of : [
										parser.exact { word : "," },
										space { preferred : True }
									]
								}
							},
							parser.exact { word : "]" }
						]
					}
					apply_environment_to : [ environment.list_of { field : $items } ]
					ensure_type_is : ensure_type.frame { }
					type_demand : ensure_type.propagate_all {
						field : $items
						needs_unbox : False
					}
					api_value : apigen.other_list { field : $items }
					code_value : codegen.push_source_reference {
						in : codegen.mash_into_frame {
							field : $items
						}
					}
				}

				container : Template literal_tmpl {
					pretty_name : "access containing frame"
					name : "Container"
					ensure_type_is : ensure_type.frame { }
					apply_environment_to : [ environment.top_level { desired : False } ]
					code_value : parameters.container_frame
				}
				false : Template literal_tmpl {
					pretty_name : "logical false"
					name : "False"
					ensure_type_is : ensure_type.bool { }
					code_value : kws.numeric_constant {
						item_type : type.bool
						number : min
					}
				}
				float_max : Template literal_tmpl {
					pretty_name : "largest floating-point value"
					name : "FloatMax"
					ensure_type_is : ensure_type.filter { types : [ type.float ] }
					code_value : kws.numeric_constant {
						item_type : type.float
						number : max
					}
				}
				float_min : Template literal_tmpl {
					pretty_name : "smallest floating-point value"
					name : "FloatMin"
					ensure_type_is : ensure_type.filter { types : [ type.float ] }
					code_value : kws.numeric_constant {
						item_type : type.float
						number : min
					}
				}
				id : Template literal_tmpl {
					pretty_name : "unique identifier for current frame"
					name : "Id"
					ensure_type_is : ensure_type.filter { types : [ type.str ] }
					code_value : kws.frame_id {
						source : parameters.self_frame
					}
				}
				infinity : Template literal_tmpl {
					pretty_name : "floating-point infinite value"
					name : "Infinity"
					ensure_type_is : ensure_type.filter { types : [ type.float ] }
					code_value : kws.infinity_constant {}
				}
				int_max : Template literal_tmpl {
					pretty_name : "largest integral value"
					name : "IntMax"
					ensure_type_is : ensure_type.filter { types : [ type.int ] }
					code_value : kws.numeric_constant {
						item_type : type.int
						number : max
					}
				}
				int_min : Template literal_tmpl {
					pretty_name : "smallest integral value"
					name : "IntMin"
					ensure_type_is : ensure_type.filter { types : [ type.int ] }
					code_value : kws.numeric_constant {
						item_type : type.int
						number : min
					}
				}
				nan : Template literal_tmpl {
					pretty_name : "floating-point not-a-number"
					name : "NaN"
					ensure_type_is : ensure_type.filter { types : [ type.float ] }
					code_value : kws.nan_constant {}
				}
				null : Template literal_tmpl {
					pretty_name : "null value"
					name : "Null"
					ensure_type_is : ensure_type.filter { types : [ type.null ] }
					code_value : kws.null_constant {}
				}
				this : Template literal_tmpl {
					pretty_name : "current frame"
					name : "This"
					ensure_type_is : ensure_type.frame { }
					code_value : parameters.self_frame
				}
				true : Template literal_tmpl {
					pretty_name : "logical truth"
					name : "True"
					ensure_type_is : ensure_type.bool { }
					code_value : kws.numeric_constant {
						item_type : type.bool
						number : max
					}
				}

				time_literal : Template expression_tmpl {
					pretty_name : "time value"
					level : max_level
					pattern : parser.accumulate_list {
						field : $parts
						item_type : $time
						in : parser.many {
							of : parser.other {
								item_type : $time
								accumulate : True
								field : Null
							}
							nonempty : True
						}
					}
					apply_environment_to : [ ]
					ensure_type_is : ensure_type.filter { types : [ type.int ] }
					api_value : apigen.nop {}
					code_value : codegen.fold_others {
						target_flavour : codegen.flavour_accumulate
						field : $parts
						initial : kws.numeric_constant {
							item_type : type.int
							number : 0
						}
					}
				}
				integer_literal : Template expression_tmpl {
					pretty_name : "integral value"
					level : max_level
					pattern : parser.accumulate_integer {
						field : $amount
						in : parser.sequence {
							of : [
								valid_number {},
								parser.except { char : ".eGMkdhms" }
							]
						}
					}
					apply_environment_to : [ ]
					ensure_type_is : ensure_type.filter { types : [ type.int, type.float ] }
					api_value : apigen.nop {}
					code_value : kws.numeric_constant {
						item_type : type.int
						number : $amount
					}
				}
				hex_integer_literal : Template expression_tmpl {
					pretty_name : "hexidecimal integral value"
					level : max_level
					pattern : parser.accumulate_integer {
						field : $amount
						in : parser.sequence {
							of : [
									parser.exact { word : "0x" },
									parser.many {
										nonempty : True
										of : hex_digit { }
									}
								]
						}
					}
					apply_environment_to : [ ]
					ensure_type_is : ensure_type.filter { types : [ type.int ] }
					api_value : apigen.nop {}
					code_value : kws.numeric_constant {
						item_type : type.int
						number : $amount
					}
				}
				int_ik : Template int_with_unit_expr_tmpl { symbol : "ki"  unit : 1024 }
				int_im : Template int_with_unit_expr_tmpl { symbol : "Mi"  unit : 1024 * 1024 }
				int_ig : Template int_with_unit_expr_tmpl { symbol : "Gi"  unit : 1024 * 1024 * 1024 }
				int_sk : Template int_with_unit_expr_tmpl { symbol : "k"  unit : 1000 }
				int_sm : Template int_with_unit_expr_tmpl { symbol : "M"  unit : 1000 * 1000 }
				int_sg : Template int_with_unit_expr_tmpl { symbol : "G"  unit : 1000 * 1000 * 1000 }
				float_literal : Template expression_tmpl {
					pretty_name : "floating-point value"
					level : max_level
					pattern : parser.accumulate_float {
						field : $value
						in : parser.sequence {
							accumulate : True
							of : [
								valid_number {},
								parser.single { char : "." },
								parser.many {
									of : parser.range { from : "0" to : "9" }
								},
								parser.optional {
									of : parser.sequence {
										of : [
											parser.single { char : "eE" },
											parser.optional {
												of : parser.single { char : "-" }
											},
											valid_number {}
										]
									}
								}
							]
						}
					}
					apply_environment_to : [ ]
					ensure_type_is : ensure_type.filter { types : [ type.float ] }
					api_value : apigen.nop {}
					code_value : kws.numeric_constant {
						item_type : type.float
						number : $value
					}
				}

				string_identifier : Template expression_tmpl {
					pretty_name : "string from identifier"
					level : max_level
					pattern : parser.sequence {
						of : [
							parser.exact { word : "$" },
							valid_identifier { field : $name }
						]
					}
					apply_environment_to : [ ]
					ensure_type_is : ensure_type.filter { types : [ type.str ] }
					api_value : apigen.nop {}
					code_value : kws.string_constant_from_field {
						field : $name
					}
				}
				string_literal : Template expression_tmpl {
					pretty_name : "string literal"
					level : max_level
					pattern : parser.sequence {
						of : [
							parser.exact { word : "\\\"" },
							parser.accumulate_list {
								field : $parts
								item_type : $string_piece
								in : parser.many {
									of : parser.other {
										item_type : $string_piece
										field : Null
									}
								}
							},
							parser.exact { word : "\\\"" }
						]
					}
					apply_environment_to : [ environment.list_of { field : $parts } ]
					ensure_type_is : ensure_type.filter { types : [ type.str ] }
					api_value : apigen.other_list { field : $parts }
					code_value : codegen.collapse_others {
						item_type : type.str
						field : $parts
						initial : kws.string_constant { str : "" }
					}
				}
			}
		}
	}
}

kws_repl_tmpl : Template kws_tmpl {
	set_current : Template codegen.gen_tmpl {
		arguments : [ { value : to  item_type : type.frame } ]
		return_type : type.frame
		to : Required
	}
	print : Template codegen.gen_tmpl {
		escape : False
		item : Required
	}
}

language_with_repl_tmpl : Template language_tmpl {
	repl_tmpl : Template syntax_element {
		pretty_name : keyword & " in REPL"
		keyword : Required
		help : Required
		api_value : apigen.nop {}
	}
	repl_simple_tmpl : Template repl_tmpl {
		arg_help : ""
		pattern : parser.sequence {
			of : [
				space {},
				parser.exact { word : keyword },
				space {}
			]
		}
		apply_environment_to : []
	}
	repl_expr_tmpl : Template repl_tmpl {
		arg_help : " <expr>"
		pattern : parser.sequence {
			of : [
				space {},
				parser.exact { word : keyword },
				space {},
				parser.other { item_type : $expression  alternate : $expression0 field : $expr },
				space {}
			]
		}
		apply_environment_to : [
			environment.blank_environment {
				apply_to : [ environment.other_elements { fields : [ $expr ] } ]
				name : $blank
			}
		]
		type_demand : ensure_type.frame { ensure_type_of : ensure_type.propagate { fields : [ $expr ] } }
	}

	adapt_repl_environment : Template codegen.push_source_reference {
		for : Required
		inherit : False
		in : codegen.bind {
			define : {
				context : kws.frame_context { source : parameters.current }
				self_frame : parameters.current
				container_frame : kws.frame_container { source : parameters.current }
			}
			in : Template codegen.prepare_lookup_cache {
				inherit : False
				name : $blank
				in : for { }
			}
		}
	}
	repl_do_and_continue : Template codegen.bind {
		action : Required
		define : {
			junk : action
		}
		in : Template kws.numeric_constant {
			item_type : type.bool
			number : max
		}
	}

	rule_groups +: {
		repl : Template syntax_group {
			environment_enabled : True
			generation_flavour : codegen.flavour_repl
			common +: {
				comment : common_fields.str
			}
			rules +: {
				quit : Template repl_simple_tmpl {
					keyword : "Quit"
					help : "Stop with the Flabbergast."
					code_value : kws.numeric_constant {
						item_type : type.bool
						number : min
					}
				}
				goto : Template repl_expr_tmpl {
					keyword : "Go"
					help : "Change the current frame (This) to some other frame."
					code_value : repl_do_and_continue {
						action : adapt_repl_environment {
							for : Template kws.set_current {
								to : codegen.other_code {
									target_flavour : codegen.flavour_aware
									field : $expr
								}
							}
						}
					}
				}
				ls : Template repl_simple_tmpl {
					keyword : "Ls"
					help : "List the names of the attributes in the current frame (This)."
					apply_environment_to : [
						environment.blank_environment {
							apply_to : []
							name : $blank
						}
					]
					code_value : kws.print {
						item : adapt_repl_environment {
							for : Template kws.iterator {
								input : input_list { items : [ parameters.current ] }
								initial : kws.string_constant { str : "Attributes:" }
								default_case : kws.string_concatenate {
									first : current_accumulator
									second : kws.string_concatenate {
										first : kws.string_constant { str : "\t" }
										second : current_name
									}
								}
								cases : []
								accumulator_type : type.str
							}
						}
					}
				}
				up : Template repl_simple_tmpl {
					keyword : "Up"
					help : "Change the current frame (This) to the containing frame (Container)."
					code_value : repl_do_and_continue {
						action : kws.set_current {
							to : kws.frame_container {
								source : parameters.current
							}
						}
					}
				}
				home : Template repl_simple_tmpl {
					keyword : "Home"
					help : "Change the current frame (This) to the file-level frame."
					code_value : repl_do_and_continue {
						action : kws.set_current {
							to : kws.frame_container {
								source : parameters.root
							}
						}
					}
				}
				trace : Template repl_simple_tmpl {
					keyword : "Trace"
					help : "Print the stack trace for the current frame."
					code_value : kws.print {
						item : kws.frame_trace {
							source : parameters.current
							prefix : kws.string_constant { str : "" }
						}
					}
				}
				expr : Template syntax_element {
					pretty_name : "Expression in REPL"
					keyword : Null
					help : Null
					pattern : parser.sequence {
						of : [
							space {},
							parser.other { item_type : $expression  alternate : $expression0 field : $expr },
							space {}
						]
					}
					api_value : apigen.other { fields : [ $expr ] }
					code_value : kws.print {
						escape : True
						item : adapt_repl_environment {
							for : Template codegen.other_code {
								target_flavour : codegen.flavour_aware
								field : $expr
							}
						}
					}
					apply_environment_to : [
						environment.blank_environment {
							apply_to : [ environment.other_elements { fields : [ $expr ] } ]
							name : $blank
						}
					]
					type_demand : ensure_type.propagate {
						fields : [ $expr ]
						needs_unbox : False
					}
				}
				help : Template repl_simple_tmpl {
					keyword : "Help"
					help : "This dreck."
					apply_environment_to : []
					code_value : kws.print {
						item : kws.string_constant {
							str : For rule : expanded_rules
								Where !(rule.keyword Is Null)
								Reduce "\(acc)\\n\(rule.keyword)\(rule.arg_help)\t\(rule.help)"
								With acc : "Interactive Shell Help\\n"
						}
					}
				}
			}
		}
	}
}
