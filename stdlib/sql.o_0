Introduction{{{Support for interface with SQL relational databases}}}

utils_lib : From lib:utils
{{{Query an SQL database and produce a frame containing a frame for each row.

The names of the columns, which must be valid Flabbergast identifiers, will be
the attribute names in each “row” frame. If the column name is empty it will
become the attribute name of the “row” frame in the containing frame,
otherwise, the “row” frames will be numbered.}}}
retrieve : Template From native:sql.query {
	{{{A connection from a \Mono{From sql:} import}}}
	connection : Required
	{{{A string containing the implementation-specific SQL statement.}}}
	sql_query : Required
	{{{The template to be used for each row. When the query is evaluated, this
	template is expanded for each row and the columns, except \Mono{ATTRNAME},
	from the database are overrides on the row.}}}
	sql_row_tmpl : Used
}

{{{Create an SQL-statement generating template.}}}
queryifier : Template {
	{{{The template to modify.}}}
	base : Required
	value : Template base {
		{{{A frame of expressions or columns to be included in the resulting table.}}}
		columns : Required
		{{{A collection of expressions (or columns) that must be true to include a
		row in the results.}}}
		where : Template {}

		{{{A collection of expressions (or columns) by which to group the resulting
		columns.}}}
		group_by : Template {}

		{{{The collection of columns available from each of the tables specified in
		\{tables}. These can be used in any place that accepts an expression. Given
		there is a column \Mono{c} in a table \Mono{t}, reference it as
		\Mono{column.t.c}.}}}
		column :
			For t : table, name : Name
				Select name : t.known_columns
		{{{Provides templates for construction expressions. See \{sql_provider} for details.}}}
		expr : provider.expr

		{{{The correct database provider from \{sql_providers}.}}}
		provider : Required

		{{{Expand the where template.}}}
		exp_where : where {}

		{{{Expand the group by template.}}}
		exp_group : ({ value : group_by {}  sql_aggregate_context : "GROUP BY" }).value

		{{{A template of templates to generate special tables to be embedded in the query. These can be literal tables (see \{sql_literal_table_tmpl}) or aliases of real tables (see \{alias_table_tmpl}).}}}
		user_defined_tables : Template {}

		{{{A collection of tables provided by the database.}}}
		table :
			For table_tmpl : user_defined_tables {}, name : Name
				Select name : table_tmpl {}

		{{{A list of tables, inferred from \{columns}, to be included in this
		query.}}}
		tables :
			For x : columns Append exp_group
				Reduce
					For t : x.sql_tables, a : acc, name : Name Select name : (t ?? a) Enforce Str
				With acc : {}

		{{{Generate the \Mono{FROM} clause.}}}
		from_clause :
			For t : tables Concat t With ", "
		{{{Generate the columns in the \Mono{SELECT}.}}}
		column_clause :
			For col : columns, name : Name, pos : Ordinal
				Concat col.sql_expr & " AS " & provider.symbol_start Enforce Str & provider.escape_symbol(name) & provider.symbol_end Enforce Str
				With ", "
		column_parameters :
			For col : columns
				Reduce acc Append col.sql_parameters
				With acc : []
		{{{Generate the \Mono{WHERE} clause, if any.}}}
		where_clause :
			For clause : exp_where, position : Ordinal
				Reduce (If position > 1 Then acc & " AND " Else " WHERE ") & clause.sql_expr
				With acc : ""
		where_parameters :
			For clause : exp_where, position : Ordinal
				Reduce acc Append clause.sql_parameters
				With acc : []
		sql_aggregate_context : Null
		sql_non_aggregate_result_cols :
			For x : columns Append exp_where
				Reduce For acc_cols : acc, x_cols : x.sql_non_aggregate_columns, name : Name Select name : acc_cols ?? x_cols.sql_expr
				With acc : {}
		sql_group_cols :
			For x : exp_group
				Reduce For acc_cols : acc, x_cols : x.sql_non_aggregate_columns, name : Name Select name : acc_cols ?? x_cols.sql_expr
				With acc : {}
		sql_results_contain_aggregate :
			For x : columns Append exp_where
				Reduce For a : acc, s : x.sql_aggregated_tables, n : Name Select n : (a ?? s)
				With acc : {}

		ungrouped_aggregate_cols :
			(For group : sql_group_cols, result : sql_non_aggregate_result_cols
					Where group Is Null
					Concat result
					With " ") ?? ""

		group_clause :
			If (For s : sql_results_contain_aggregate Count) > 0 && Length (ungrouped_aggregate_cols Enforce Str) > 0
				Then Error ("The following columns are not grouped:" & ungrouped_aggregate_cols)
				Else
					(For clause : exp_group, position : Ordinal
						Reduce (If position > 1 Then acc & ", " Else " GROUP BY ") & clause.sql_expr
						With acc : "")
		group_parameters :
					For clause : exp_group
						Reduce acc Append clause.sql_parameters
						With acc : []
		{{{Generate the total query.}}}
		sql_query :
			If column_clause Is Null Then Error "No columns specified in query."
			Else "SELECT " & column_clause Enforce Str & (If from_clause Is Null Then provider.null_from Else " FROM " & from_clause Enforce Str) & where_clause Enforce Str & group_clause Enforce Str
		{{{A positional list of parameters. These are useful if generating queries with \Mono{?} that need matching information to fill in.}}}
		sql_parameters : column_parameters Append where_parameters Append group_parameters
	}
}

{{{Query an SQL database for the delicious records within.}}}
query : Template queryifier(base : retrieve) {
		{{{A collection of tables provided by the database.}}}
		table +orig:
			For discovered : provider.table_discovery(connection : connection), defined : orig, name : Name
				Select name :
					If !(discovered Is Null) && !(defined Is Null)
						Then Error "Table \(name Enforce Str) is present in the database but also manually defined."
						Else (discovered ?? defined) Enforce Frame
		{{{The default set of columns to retreive is all known columns from the selected tables.}}}
		columns :
			For col : column
				Reduce For acc_value : acc, col_value : col, name : Name
					Select name : acc_value ?? col_value
				With acc : {}
		{{{The provider, automatically selected from the database connection.}}}
		provider :
			((For provider : sql_providers, provider_name : Name
				Where provider_name == connection.provider Enforce Str
				Reduce provider With acc : Null) ?? (Error "Unsupported database “\(connection.provider Enforce Str)”. This library must be mismatched to the Flabbergast runtime.")) {}
}

{{{Create an SQL query without a connection to the database. The tables and
columns available must be manually curated.}}}
offline_query : queryifier(base : Template { value : sql_query })
{{{The template to create a table for an offline query.}}}
offline_table_tmpl : Template {
	{{{The name of the schema this table belongs to.}}}
	table_schema : Required
	{{{The name of this table in this schema.}}}
	table_name : Required
	{{{The columns in this table, using the \{column_tmpl}.}}}
	columns : Template {}
	{{{The template to use for each column.}}}
	column_tmpl : Template provider.expr.base_expr_tmpl {
		{{{The name of the column.}}}
		column_name : Required
		{{{The type of the column. If not specified, it is assumed to be a string.}}}
		sql_type : sql_types.str

		sql_tables : Now { Attribute(Id) : Now This }
		sql_column : column_name

		sql_expr : sql_from Enforce Str & "." & provider.symbol_start Enforce Str & column_name Enforce Str & provider.symbol_end Enforce Str
		sql_non_aggregate_columns : { Attribute(Id) : Now This }
		sql_aggregated_tables : {}
		sql_parameters : []
	}

	known_columns : columns {}
	aliasable_table : True
	sql_from : (If table_schema Is Null Then "" Else provider.symbol_start Enforce Str & table_schema Enforce Str & provider.symbol_end Enforce Str & ".") & provider.symbol_start Enforce Str & table_name Enforce Str & provider.symbol_end Enforce Str
}
{{{A new set of names for existing tables. This allows duplicating tables for self-joins and the like. Set the value to be a table from \{table}.}}}
alias_table_tmpl : Template {
	{{{The real table from which this table is aliased.}}}
	backing : Required
	aliasable_table : False
	sql_from : If backing.aliasable_table Then backing.sql_from Enforce Str & " AS " & name Else Error "Cannot create alias \(name). The backing table is not aliasable."
	known_columns : Let this_table : { Attribute(Id) : sql_from } In
		For backing_column : backing.known_columns, col_name : Name Select col_name : provider.expr.base_expr_tmpl {
				sql_expr : name & "." & sql_column
				sql_column : backing_column.sql_column
				sql_type : backing_column.sql_type
				sql_tables : this_table
				sql_non_aggregate_columns : { Attribute(Id) : Now This }
				sql_aggregated_tables : {}
				sql_parameters : []
		}
}


{{{Convert a value into a SQL expression if possible.}}}
sql_marshall : utils_lib.str_concatifier(base : sql_marshall_list, delimiter : "") Enforce Template

{{{Convert a list of Flabbergast items to an SQL expression.}}}
sql_marshall_list : Template {
	provider : Required
	value :
		For arg : args, arg_name : Name
		Select arg_name : ((Lookup sql_marshall_converters.TypeOf(arg) Here) {}).value
}

sql_marshall_converters : {
	bin :
		Template {
			value : provider.expr.base_const_tmpl {
				sql_expr : provider.blob_start Enforce Str & utils_lib.bin_to_hex_str(arg, uppercase : True) Enforce Str & provider.blob_end Enforce Str
				sql_type : sql_types.blob
			}
		}
	bool :
		Template {
			value : provider.expr.base_const_tmpl {
				sql_expr : If arg Then "TRUE" Else "FALSE"
				sql_type : sql_types.bool
			}
		}
	float :
		Template {
			value : provider.expr.base_const_tmpl {
				sql_expr : arg To Str
				sql_type : sql_types.float
			}
		}
	frame : Template { value : arg }
	int :
		Template {
			value : provider.expr.base_const_tmpl {
				sql_expr : arg To Str
				sql_type : sql_types.int
			}
		}
	lookup_handler : Template { value : Error "Cannot convert lookup handler to SQL." }
	null : Template { value :  Null }
	template : Template { value : Error "Cannot convert template to SQL." }
	str :
		Template {
			value : provider.expr.base_const_tmpl {
				sql_expr : provider.quote_start Enforce Str & provider.escape(arg) Enforce Str & provider.quote_end Enforce Str
				sql_type : sql_types.str
			}
		}
}

{{{Compute the SQL type of a complex expression.}}}
synthetic_sql_type : Template {
	coerce : Required
	id : 0
	cast :
		For type : sql_types
			Where type Is Frame
			Reduce If type.id B& coerce != 0
				Then acc B| type.cast
				Else acc
			With acc : 0
	name :
		(For type : sql_types
			Where type Is Frame && type.id B& coerce != 0
			Reduce If acc Is Null
				Then type.name Enforce Str
				Else acc Enforce Str & " or " & type.name Enforce Str
			With acc : Null) ?? "none"
}

{{{A table from Flabbergast to be embedded in the query. It should probably be short.}}}
sql_literal_table_tmpl : Template {
  {{{A list of frames to convert to rows in the table. If any attributes are missing in some rows, nulls will be substituted. }}}
	rows : Required
	marshalled_rows : For row : rows Select sql_marshall_list(args : row, provider : provider)
	column_types :
		For row : marshalled_rows
			Reduce
				For r : row, a : acc, n : Name
					Select n : If a Is Null || r Is Null Then r?.sql_type ?? a Else synthetic_sql_type { coerce : a.coerce B& r.sql_type.coerce }
			With acc : {}
	table_name : Id
	known_columns :
		For type : column_types, name : Name
			Select name :
				If type.coerce == 0
					Then Error "Column “\(name)” in literal table does not have consistent type."
					Else column_tmpl { sql_expr : provider.symbol_start Enforce Str & table_name Enforce Str & provider.symbol_end Enforce Str & "." & provider.symbol_start Enforce Str & name & provider.symbol_end Enforce Str  sql_type : type }
	column_tmpl : Template {
		sql_tables : Now { Attribute(Id) : Now This }
		sql_non_aggregate_columns : { Attribute(Id) : Now This }
		sql_aggregated_tables : {}
		sql_parameters : []
	}
	aliasable_table : False
	sql_from : (provider.generate_literal_from {}).value
}

sql_arith_ops : {
	add : { id : 1  symbol : "+" }
	sub : { id : 2  symbol : "-" }
	mul : { id : 4  symbol : "*" }
	div : { id : 8  symbol : "/" }
	mod : { id : 16  symbol : "%" }
}

{{{All the rules for arithemtic operations in SQL.}}}
sql_arithmetic_rules : {
	Attribute(sql_types.float.id B| sql_types.int.id) : {
		Attribute(sql_types.float.id B| sql_types.int.id) : {
			Attribute(sql_arith_ops.add.id B| sql_arith_ops.sub.id B| sql_arith_ops.mul.id B| sql_arith_ops.div.id) : Template {
				result_type : synthetic_sql_type { coerce : specials.l.sql_type.coerce B& specials.r.sql_type.coerce }
				value : "(" & specials.l.sql_expr Enforce Str & sql_op.symbol Enforce Str & specials.r.sql_expr Enforce Str & ")"
			}
			Attribute(sql_arith_ops.mod.id) : Template {
				result_type : Now sql_types.int
				value : "(" & specials.l.sql_expr Enforce Str & sql_op.symbol Enforce Str & specials.r.sql_expr Enforce Str & ")"
			}
		}
	}
	Attribute(sql_types.timestamp.id) : {
		Attribute(sql_types.interval.id) : {
			Attribute(sql_arith_ops.add.id B| sql_arith_ops.sub.id) : Template {
				result_type : Now sql_types.timestamp
				value : "(" & specials.l.sql_expr Enforce Str & sql_op.symbol Enforce Str & specials.r.sql_expr Enforce Str & ")"
			}
		}
		Attribute(sql_types.timestamp.id) : {
			Attribute(sql_types.timestamp.id) : {
				Attribute(sql_arith_ops.sub.id): Template {
					result_type : Now sql_types.interval
					value : "(" & specials.l.sql_expr Enforce Str & sql_op.symbol Enforce Str & specials.r.sql_expr Enforce Str & ")"
				}
			}
		}
	}
	Attribute(sql_types.interval.id) : {
		Attribute(sql_types.int.id) : {
			Attribute(sql_arith_ops.mul.id) : Template {
				result_type : Now sql_types.interval
				value : "(" & specials.l.sql_expr Enforce Str & sql_op.symbol Enforce Str & specials.r.sql_expr Enforce Str & ")"
			}
		}
		Attribute(sql_types.interval.id) : {
			Attribute(sql_arith_ops.add.id B| sql_arith_ops.sub.id) : Template {
				result_type : Now sql_types.interval
				value : "(" & specials.l.sql_expr Enforce Str & sql_op.symbol Enforce Str & specials.r.sql_expr Enforce Str & ")"
			}
		}
	}
}

sql_types : {
	blob : {
		name : "BLOB"
		id : 64
		cast : blob.id
		coerce : blob.id
		cast_name : Template { value : provider.cast_name.blob }
	}
	bool : {
		name : "BOOLEAN"
		id : 1
		cast : bool.id B| int.id B| str.id
		coerce : bool.id B| str.id
		cast_name : Template { value : provider.cast_name.boolean }
	}
	float : {
		name : "DOUBLE"
		id : 2
		cast : int.id B| str.id
		coerce : float.id B| str.id
		cast_name : Template { value : provider.cast_name.double }
	}
	int : {
		name : "INTEGER"
		id : 4
		cast : bool.id B| float.id B| str.id
		coerce : int.id B| float.id B| str.id
		cast_name : Template { value : provider.cast_name.int }
	}
	interval : {
		name : "INTERVAL"
		id : 32
		cast : 0
		coerce : interval.id B| str.id
		cast_name : Template { value : provider.cast_name.interval }
	}
	str : {
		name : "TEXT"
		id : 8
		cast : bool.id B| int.id B| float.id B| str.id
		coerce : str.id
		cast_name : Template { value : provider.cast_name.str }
	}
	timestamp : {
		name : "TIMESTAMP"
		id : 16
		cast : 0
		coerce : str.id B| timestamp.id
		cast_name : Template { value : provider.cast_name.timestamp }
	}
	any : blob.id B| bool.id B| int.id B| interval.id B| float.id B| str.id B| timestamp.id
	numeric : int.id B| float.id
}

{{{A template for implementing a new SQL provider.}}}
sql_provider : Template {
	{{{The expression templates available for instantiation.}}}
	expr : allowed_expressions {}
	{{{A transformation set for string escaping. Yes, this is not standard.}}}
	transformations : Required
	{{{The preamble starting a string.}}}
	quote_start : "'"
	{{{The postamble end a string.}}}
	quote_end : "'"
	{{{The preamble of a symbol (table, schema, or column name).}}}
	symbol_start : "\""
	{{{The postamble of a symbol (table, schema, or column name).}}}
	symbol_end : "\""
	{{{The preamble of a blob.}}}
	blob_start : "X'"
	{{{The postamble of a blob.}}}
	blob_end : "'"
	{{{The names used for casting on this provider.}}}
	casting_name : Template {
		blob : "BLOB"
		bool : "BOOLEAN"
		float : "DOUBLE"
		int : "INTEGER"
		interval : "INTERVAL"
		str : "TEXT"
		timestamp : "TIMESTAMP"
	}
	{{{The \Mono{FROM} clause to use for a query with no tables.}}}
	null_from : ""
	{{{An SQL statement that returns tables and views as a frame of frames with a
	\{sql_from} containing the string needed to include this entity in a
	\Mono{FROM} clause. Other implementation-specific attributes are permitted.}}}
	table_discovery : Template retrieve {
		sql_row_tmpl : Template {
			sql_from : Required
			aliasable_table : True
			known_columns : column_discovery(connection : connection, table : This)
		}
	}
	{{{An SQL statement that will return the columns for a particular table or
	view as a frame of frames extending \{expr.base_expr_tmpl}. Other
	implementation-specific attributes are permitted.}}}
	column_discovery : Template retrieve {
		table : Required
		sql_row_tmpl : Template expr.base_expr_tmpl {
			sql_tables : Now { Attribute(GenerateId table) : table.sql_from }
			sql_non_aggregate_columns : { Attribute(Id) : Now This }
			sql_aggregated_tables : {}
			sql_parameters : []
		}
	}
	cast_name : casting_name {}
	{{{List of arithmetic rules this database supports.}}}
	sql_arithmetic_rules : Used
	{{{Generate a FROM clause containing literal data.}}}
	generate_literal_from : Template {
		column_list :
			symbol_start Enforce Str & table_name Enforce Str & symbol_end Enforce Str & "("
			(For name : Name, type : column_types, pos : Ordinal
				Concat symbol_start Enforce Str & name & symbol_end Enforce Str With ",")
			& ")"
		value_list :
			For row : marshalled_rows, pos : Ordinal
				Concat
					"("
						& (For column : row Concat (column?.sql_expr ?? "NULL") With ",")
						& ")"
				With ","
		value : "(VALUES " & value_list Enforce Str & ") AS " & column_list
	}
	{{{The kinds of expressions that maybe used in an SQL query.}}}
	allowed_expressions : Template {
		{{{A base template representing an expression or column in a SQL query.}}}
		base_expr_tmpl : Template {
			{{{A string containing the SQL code needed to access this column.}}}
			sql_expr : Required
			{{{A member of \{sql_types} that represents the Flabbergast type to which
			this expression will be converted.}}}
			sql_type : Required
			{{{All the tables required by this expression.}}}
			sql_tables : Required
			{{{Any columns that are not arguments to an aggregate function.}}}
			sql_non_aggregate_columns : Required
			{{{All the tables that are under aggegation in this expression.}}}
			sql_aggregated_tables : Required
			{{{All of the parameter values from the arguments of this expression.}}}
			sql_parameters : Required
		}
		{{{A template to allow creating expressions from existing expressions.}}}
		proxy_tmpl : Template base_expr_tmpl {
			{{{The real expression to use.}}}
			inner : Required
			sql_expr : inner.sql_expr
			sql_type : inner.sql_type
			sql_tables : inner.sql_tables
			sql_non_aggregate_columns : innert.sql_non_aggregate_columns
			sql_aggregated_tables : inner.sql_aggregated_tables
			sql_parameters : inner.sql_parameters
		}
		base_const_tmpl : Template base_expr_tmpl {
			sql_tables : {}
			sql_non_aggregate_columns : {}
			sql_aggregated_tables : {}
			sql_parameters : []
		}
		base_unary_expr_tmpl : Template base_expr_tmpl {
			{{{The argument to cast.}}}
			arg : Required
			sql_tables : arg.sql_tables
			sql_non_aggregate_columns : arg.sql_non_aggregate_columns
			sql_aggregated_tables : arg.sql_aggregated_tables
			sql_parameters : arg.sql_parameters
		}
		base_unary_function_tmpl : Template base_unary_expr_tmpl {
			sql_arg_type : Required
			sql_func : Required
			sql_expr : If sql_arg_type.id B& arg.sql_type.coerce == 0
				Then Error "Cannot convert \(arg.sql_type.name) to \(sql_arg_type.name)."
				Else sql_func Enforce Str & "(" & arg.sql_expr Enforce Str & ")"
		}
		base_binary_expr_tmpl : Template base_expr_tmpl {
			left : Required
			right : Required
			specials : sql_marshall_list(args : { l : left  r : right }, provider : provider)
			sql_tables : For left_table : specials.l.sql_tables, right_table : specials.r.sql_tables, name : Name Select name : left_table ?? right_table
			sql_non_aggregate_columns : For left_cols : specials.l.sql_non_aggregate_columns, right_cols : specials.r.sql_non_aggregate_columns, name : Name Select name : (left_cols ?? right_cols)
			sql_aggregated_tables : For l : specials.l.sql_aggregated_tables, r : specials.r.sql_aggregated_tables, n : Name Select n : (l ?? r)
			sql_parameters : specials.l.sql_parameters Append specials.r.sql_parameters
		}
		base_arith_expr_tmpl : Template base_binary_expr_tmpl {
			sql_rule :
				(Lookup arithmetic_rules.Attribute(specials.l.sql_type.coerce).Attribute(specials.r.sql_type.coerce).Attribute(sql_op.id) Using (From lib:lookup).flag_contains_handler In provider) {}
			sql_type : sql_rule.result_type
			sql_expr : sql_rule.value
		}
		base_args_tmpl : Template base_expr_tmpl {
			sql_args : sql_marshall_list(args : args, provider : provider)
			sql_tables :
				For arg : sql_args
					Reduce For table : arg.sql_tables, acc_table : acc, name : Name Select name : table ?? acc_table
					With acc : {}
			sql_parameters :
				For arg : sql_args
					Reduce acc Append arg.sql_parameters
					With acc : []
		}
		base_infix_expr_tmpl : Template base_args_tmpl {
			{{{The expressions to be put together.}}}
			args : Required

			{{{The infix operation symbol.}}}
			sql_op : Required

			{{{The bits for the allowed types of arguments.}}}
			sql_allowed_arg_type_id : Required

			sql_expr :
				If sql_type.coerce == 0 Then Error "Cannot compute type." Else
					"(" & (For arg : sql_args Concat arg.sql_expr With sql_op) & ")"

			sql_type : synthetic_sql_type {
				coerce :
					For arg : sql_args, pos : Ordinal
						Reduce
							If acc B& arg.sql_type.coerce == 0
								Then Error "Argument \(pos) to \(sql_op) has incompatible type \(arg.sql_type.name)."
								Else acc B& arg.sql_type.coerce
						With acc : sql_allowed_arg_type_id
			}
			sql_non_aggregate_columns :
				For arg : sql_args
					Reduce For acc_cols : acc, arg_cols : arg.sql_non_aggregate_columns, name : Name Select name : acc_cols ?? arg_cols
					With acc : {}
			sql_aggregated_tables :
				For arg : sql_args
					Reduce For a : acc, r : arg.sql_aggregated_tables, n : Name Select n : (a ?? r)
					With acc : {}
		}
		base_function_expr_tmpl : Template base_args_tmpl {
			{{{The expressions to be put together.}}}
			args : Required

			{{{The function name.}}}
			sql_func : Required
			{{{A list of argument types.}}}
			arg_types : Required

			sql_expr :
				(For arg : sql_args, arg_type : arg_types, pos : Ordinal
					Reduce
						If arg_type.id B& arg.sql_type.coerce == 0
							Then Error "Incompatible type \(arg.sql_type.name) for argument \(pos) to \(sql_func). Expected \(arg_type.name)."
							Else acc & (If pos > 1 Then "," Else "") & arg.sql_expr
					With acc : sql_func & "(") & ")"
			sql_non_aggregate_columns :
				For arg : sql_args
					Reduce For acc_cols : acc, arg_cols : arg.sql_non_aggregate_columns, name : Name Select name : acc_cols ?? arg_cols
					With acc : {}
			sql_aggregated_tables :
				For arg : sql_args
					Reduce For a : acc, r : arg.sql_aggregated_tables, n : Name Select n : (a ?? r)
					With acc : {}
		}
		base_aggregate_func_tmpl : Template base_expr_tmpl {
			{{{The expression aggregate.}}}
			arg : Required

			{{{The function name.}}}
			sql_func : Required
			{{{The bits for the allowed types of arguments.}}}
			sql_allowed_arg_type_mask : Required
			{{{Extra arguments, if required.}}}
			sql_extra_args : ""

			sql_aggregate_context : sql_func & " function arguments"
			parent_sql_aggregate_context : Lookup sql_aggregate_context In Container

			sql_expr :
				If !(parent_sql_aggregate_context Is Null)
					Then Error "Aggregate function \(sql_func) not allowed in \(parent_sql_aggregate_context)."
				Else If arg.sql_type.coerce B& sql_allowed_arg_type_mask == 0
					Then Error "Bad type in \(sql_func)."
					Else sql_func & "(" & arg.sql_expr & sql_extra_args & ")"
			sql_tables : arg.sql_tables
			sql_type : synthetic_sql_type {
				coerce : arg.sql_type.coerce B& sql_allowed_arg_type_mask
			}
			sql_non_aggregate_columns : {}
			sql_aggregated_tables : arg.sql_tables
			sql_parameters : arg.sql_parameters
		}
		base_variadic_func_tmpl : Template base_args_tmpl {
			{{{The expressions aggregate.}}}
			args : Required

			{{{The infix operation symbol.}}}
			sql_func : Required

			{{{The bits for the allowed types of arguments.}}}
			sql_allowed_arg_type_id : Required

			sql_expr :
				If sql_type.coerce == 0 Then Error "Bad type in \(sql_func)." Else
				sql_func & "(" & (For arg : sql_args Concat arg.sql_expr With ", ") & ")"

			sql_type : synthetic_sql_type {
				coerce :
					For arg : sql_args, pos : Ordinal
						Reduce
							If acc B& arg.sql_type.coerce == 0
								Then Error "Argument \(pos) to \(sql_func) has incompatible type \(arg.sql_type.name)."
								Else acc B& arg.sql_type.coerce
						With acc : sql_allowed_arg_type_id
			}
			sql_non_aggregate_columns :
				For arg : sql_args
					Reduce For acc_cols : acc, arg_cols : arg.sql_non_aggregate_columns, name : Name Select name : acc_cols ?? arg_cols
					With acc : {}
			sql_aggregated_tables :
				For arg : sql_args
					Reduce For a : acc, r : arg.sql_aggregated_tables, n : Name Select n : (a ?? r)
					With acc : {}
		}

		base_compare_op_tmpl : Template base_binary_expr_tmpl {
			{{{The comparison symbol.}}}
			sql_op : Required
			type_mask : sql_types.any

			sql_type : sql_types.bool
			sql_expr :
				If specials.l.sql_type.coerce B& specials.r.sql_type.coerce B& type_mask == 0
					Then Error "Incompatible types in comparison."
					Else "(\(specials.l.sql_expr) \(sql_op) \(specials.r.sql_expr))"
		}
		arithmetic_fold : Template {
			first : Required
			terms : Required
			specials : sql_marshall_list(args : { f : first }, provider : provider)
			result : For term : terms Reduce term { left : Drop } With left : specials.f
			sql_expr : result.sql_expr
			sql_type : result.sql_type
			sql_tables : result.sql_tables
			sql_non_aggregate_columns : result.sql_non_aggregate_columns
			sql_aggregated_tables : result.sql_aggregated_tables
			sql_parameters : result.sql_parameters
		}

		add : Template base_arith_expr_tmpl {
			sql_op : sql_arith_ops.add
		}
		and : Template base_infix_expr_tmpl {
			sql_op : "AND"
			sql_allowed_arg_type_id : sql_types.bool.id
		}
		avg : Template base_aggregate_func_tmpl {
			sql_func : "AVG"
			sql_allowed_arg_type_mask : sql_types.numeric
		}
		base_case_tmpl : Template base_expr_tmpl {
			cases : Required
			else : Null

			when : Template {
				test : Required
				result : Required

				when_specials : sql_marshall_list(args : { t : test  r : result }, provider : provider)

				sql_type : when_specials.r.sql_type
				sql_when :
					If when_specials.t.sql_type.coerce B& sql_allowed_test_type.coerce == 0
						Then Error "Incompatible type \(when_specials.t.sql_type.name) used in test for WHEN. Expected \(sql_allowed_test_type.name)."
						Else " WHEN \(when_specials.t.sql_expr) THEN \(when_specials.r.sql_expr)"
				sql_tables : For test_table : when_specials.t.sql_tables, input_table : when_specials.r.sql_tables, name : Name Select name : test_table ?? input_table
				sql_non_aggregate_columns : For test_cols : when_specials.t.sql_non_aggregate_columns, result_cols : when_specials.r.sql_non_aggregate_columns, name : Name Select name : test_cols ?? result_cols
				sql_aggregated_tables : For l : when_specials.t.sql_aggregated_tables, r : when_specials.r.sql_aggregated_tables, n : Name Select n : (l ?? r)
				sql_parameters : when_specials.t.sql_parameters Append when_specials.r.sql_parameters
			}

			specials : Template {
				e : else
			}
			sql_specials : sql_marshall_list(args : specials {}, provider : provider)

			sql_expr :
				"(CASE " & input_expr
					& (For case : cases Concat case.sql_when With "")
					& (If sql_specials.e Is Null Then "" Else " ELSE " & sql_specials.e.sql_expr)
					& " END)"

			sql_type : synthetic_sql_type {
				coerce :
					For case : cases, pos : Ordinal
						Reduce
							If acc B& case.sql_type.coerce == 0
								Then Error "WHEN block \(pos) has incompatible type \(case.sql_type.name)."
								Else acc B& case.sql_type.coerce
						With acc : If sql_specials.e Is Null Then sql_types.any Else sql_specials.e.sql_type.coerce
			}
			sql_tables : For s : sql_specials
				Where !(s Is Null)
				Reduce For table : s.sql_tables, acc_table : acc, name : Name Select name : table ?? acc_table
				With acc : (For c : cases
						Reduce For table : c.sql_tables, acc_table : acc, name : Name Select name : table ?? acc_table
						With acc : {})
			sql_non_aggregate_columns : For s : sql_specials
				Where !(s Is Null)
				Reduce For acc_cols : acc, special_cols : s.sql_non_aggregate_columns, name : Name Select name : acc_cols ?? special_cols
				With acc : (For c : cases
					Reduce For acc_cols : acc, case_cols : c.sql_non_aggregate_columns, name : Name Select name : acc_cols ?? case_cols
					With acc : {})

			sql_aggregated_tables : For x : sql_specials Append cases
				Where !(x Is Null)
				Reduce (For c : x.sql_aggregated_tables, a : acc, n : Name Select x : (a ?? c))
				With acc : {}
			sql_parameters : For x : cases Append sql_specials
				Where !(x Is Null)
				Reduce acc Append x.sql_parameters
				With acc : []
		}
		case_bool : Template base_case_tmpl {
			sql_allowed_test_type : sql_types.bool
			input_expr : ""
		}
		case_input : Template base_case_tmpl {
			input : Required

			specials +: { i : input }
			input_expr : sql_specials.i.sql_expr
			sql_allowed_test_type : sql_specials.i.sql_type
		}
		cast : Template base_unary_expr_tmpl {
			{{{The type to change it to.}}}
			sql_type : Required
			sql_expr : If sql_type.id B& arg.sql_type.cast == 0
				Then Error "Cannot perform cast with provided types."
				Else "(CAST(\(arg.sql_expr Enforce Str) AS \((sql_type.cast_name{}).value Enforce Str)))"
		}
		contains : Template base_expr_tmpl {
			{{{An expression or literal to search for.}}}
			needle : Required
			{{{A list of expressions or literals to search through.}}}
			haystack : Required

			specials : sql_marshall_list(args : { n : needle }, provider : provider)
			haystack_marshalled : sql_marshall_list(args : haystack, provider : provider)

			sql_type : If (For h : haystack_marshalled Reduce h.sql_type.coerce B& acc With acc : specials.n.sql_type.coerce) == 0
				Then Error "No common type for needle and all haystack items."
				Else sql_types.bool

			haystack_expr :
				For h : haystack_marshalled
					Concat h.sql_expr Enforce Str
					With ","
			sql_expr :
				If haystack_expr Is Null
					Then "FALSE"
					Else "(\(specials.n.sql_expr Enforce Str) IN (\(haystack_expr Enforce Str)))"
			sql_tables : For h : haystack_marshalled
				Reduce For table : h.sql_tables, acc_table : acc, name : Name Select name : table ?? acc_table
				With acc : specials.n.sql_tables
			sql_non_aggregate_columns :
				For h : haystack_marshalled
					Reduce For acc_cols : acc, arg_cols : h.sql_non_aggregate_columns, name : Name Select name : acc_cols ?? arg_cols
					With acc : specials.n.sql_non_aggregate_columns
			sql_aggregated_tables :
				For arg : haystack_marshalled
					Reduce For a : acc, r : arg.sql_aggregated_tables, n : Name Select n : (a ?? r)
					With acc : {}
			sql_parameters :
				For arg : haystack_marshalled
					Reduce acc Append arg.sql_parameters
					With acc : specials.n.sql_parameters

		}
		contains_subquery : Template subquery {
			{{{An expression or literal to search for.}}}
			needle : Required

			specials : sql_marshall_list(args : { n : needle }, provider : provider)
			sql_type +col_type:
				If specials.n.sql_type.coerce B& col_type.coerce == 0
					Then Error "Needle and haystack are not compatible types."
					Else sql_types.bool
			sql_expr +subquery: "(\(specials.n.sql_expr Enforce Str) IN \(subquery Enforce Str)"
			sql_tables +subquery:
				For n : specials.n.sql_tables, s : subquery, name : Name
					Select name : (n ?? s)
			sql_non_aggregate_columns +subquery:
				For n : specials.n.sql_non_aggregate_columns, s : subquery, name : Name
					Select name : (n ?? s)
			sql_aggregated_tables +subquery:
				For n : specials.n.sql_aggregated_tables, s : subquery, name : Name
					Select name : (n ?? s)
		}
		count : Template base_aggregate_func_tmpl {
			sql_func : "COUNT"
			sql_allowed_arg_type_mask : sql_types.any
			sql_type : sql_types.int
		}
		div : Template base_arith_expr_tmpl {
			sql_op : sql_arith_ops.div
		}
		equal : Template base_compare_op_tmpl {
			sql_op : "=="
		}
		extract : Template base_unary_expr_tmpl {
			field : Required

			year : "YEAR"
			month : "MONTH"
			day : "DAY"
			hour : "HOUR"
			minute : "MINUTE"
			second : "SECOND"

			sql_start : "EXTRACT("
			sql_middle : " FROM "
			sql_end : ")"
			sql_type : sql_types.int
			sql_expr :
				If arg.sql_type.coerce B& sql_types.timestamp.id == 0
					Then Error "Cannot extract on non-timestamp \(arg.sql_type.name)."
					Else sql_start Enforce Str & field Enforce Str & sql_middle Enforce Str & arg.sql_expr Enforce Str & sql_end Enforce Str
		}
		ge : Template base_compare_op_tmpl {
			sql_op : ">="
		}
		gt : Template base_compare_op_tmpl {
			sql_op : ">"
		}
		greatest : Template base_variadic_func_tmpl {
			sql_func : "GREATEST"
			sql_allowed_arg_type_id : sql_types.numeric
		}
		interval_const : Template base_const_tmpl {
			{{{The number of seconds in this interval.}}}
			time : Required
			sql_type : sql_types.interval
		}
		is_null : Template base_unary_expr_tmpl {
			sql_type : sql_types.bool
			sql_expr :
				If sql_type.coerce == 0 Then Error "Bad type in null check."
					Else "(\(arg.sql_expr) IS NULL)"
		}
		le : Template base_compare_op_tmpl {
			sql_op : "<="
		}
		least : Template base_variadic_func_tmpl {
			sql_func : "LEAST"
			sql_allowed_arg_type_id : sql_types.numeric
		}
		like : Template base_binary_expr_tmpl {
			{{{Whether the matching should be case-sensitive.}}}
			case_sensitive : True
			sql_type : sql_types.bool
			sql_expr :
				If specials.l.sql_type.coerce B& specials.r.sql_type.coerce B& sql_types.str.id == 0
					Then Error "Incompatible types in comparison."
					Else If case_sensitive
						Then "(\(specials.l.sql_expr) LIKE \(specials.r.sql_expr))"
						Else "(UPPER(\(specials.l.sql_expr)) LIKE UPPER(\(specials.r.sql_expr)))"
		}
		lower : Template base_unary_function_tmpl {
			sql_arg_type : sql_types.str
			sql_type : sql_types.str
			sql_func : "LOWER"
		}
		lt : Template base_compare_op_tmpl {
			sql_op : "<"
		}
		max : Template base_aggregate_func_tmpl {
			sql_func : "MAX"
			sql_allowed_arg_type_mask : sql_types.numeric
		}
		min : Template base_aggregate_func_tmpl {
			sql_func : "MIN"
			sql_allowed_arg_type_mask : sql_types.numeric
		}
		mod : Template base_arith_expr_tmpl {
			sql_op : sql_arith_ops.mod
		}
		mul : Template base_arith_expr_tmpl {
			sql_op : sql_arith_ops.mul
		}
		negate : Template base_unary_expr_tmpl {
			sql_type : arg.sql_type
			sql_expr :
				If arg.sql_type.coerce B& sql_types.numeric != 0
					Then "(- \(arg.sql_expr))"
					Else Error "Argument to negation is not numeric."
		}
		not : Template base_unary_expr_tmpl {
			sql_type : sql_types.bool
			sql_expr :
				If arg.sql_type.coerce B& sql_types.bool.id != 0
					Then "(NOT \(arg.sql_expr))"
					Else Error "Argument to NOT expression is not Boolean."
		}
		now : Template base_const_tmpl {
			{{{Use UTC rather than local time.}}}
			utc : True
			sql_type : sql_types.timestamp
		}
		or : Template base_infix_expr_tmpl {
			sql_op : "OR"
			sql_allowed_arg_type_id : sql_types.bool.id
		}
		str_agg : Template base_aggregate_func_tmpl {
			{{{The separator expression.}}}
			separator : ""
			sql_allowed_arg_type_mask : sql_types.str.id
			specials : sql_marshall_list(args : { s : separator }, provider : provider)
			sql_tables : For a : arg.sql_tables, s : specials.s.sql_tables, n : Name Select n : a ?? s
		}
		str_join : Template base_infix_expr_tmpl {
			sql_op : "||"
			sql_allowed_arg_type_id : sql_types.str.id
		}
		str_slice : Template base_expr_tmpl {
			input : Required
			start : Required
			length : Required

			sql_substr_syntax : "SUBSTRING(" & specials.i.sql_expr & " FROM " & specials.s.sql_expr & " FOR " & specials.l.sql_expr & ")"
			specials : sql_marshall_list(args : { i : input  s : start  l : length }, provider : provider)
			sql_type : sql_types.str
			sql_expr :
				If specials.i.sql_type.coerce B& sql_types.str.id == 0 Then Error "Input of string slice is not a string."
				Else If specials.s.sql_type.coerce B& sql_types.int.id == 0 Then Error "Start of string slice is not an integer."
				Else If specials.l.sql_type.coerce B& sql_types.int.id == 0 Then Error "Length of string slice is not an integer."
				Else sql_substr_syntax
			sql_tables : For input_table : specials.i.sql_tables, start_table : specials.s.sql_tables, length_table : specials.l.sql_tables, name : Name Select name : ((input_table ?? start_table) ?? right_table) Enforce Frame
			sql_non_aggregate_columns : For s : specials
				Reduce For acc_cols : acc, special_cols : s.sql_non_aggregate_columns, name : Name Select name : acc_cols ?? special_cols
				With acc : {}
			sql_aggregated_tables : For s : specials
				Reduce For a : acc, s : s.sql_aggregated_tables, n : Name Select n : (a ?? s)
				With acc : {}
			sql_parameters : specials.i.sql_parameters Append specials.s.sql_parameters Append specials.l.sql_parameters
		}
		sub : Template base_arith_expr_tmpl {
			sql_op : sql_arith_ops.sub
		}
		subquery : Template base_expr_tmpl {
			{{{An expression (or column) from the subquery to search through.}}}
			result : Required
			{{{A collection of expressions (or columns) that must be true to include
			a row in the results.}}}
			where : Template {}

			{{{A collection of expressions (or columns) by which to group the
			resulting columns.}}}
			group_by : Template {}
			{{{A collection of tables that will be in the \Mono{FROM} clause. Any tables not listed here will be included in the outside query.}}}
			from : Template {}

			# WHERE clause
			exp_where : where {}
			where_clause :
				For clause : exp_where, position : Ordinal
					Reduce (If position > 1 Then acc & " AND " Else " WHERE ") & clause.sql_expr
					With acc : ""
			where_parameters : For clause : exp_where Reduce acc Append clause.sql_parameters With acc : []

			# All the tables used by the query
			total_tables :
				For x : [result] Append exp_where Append exp_group
					Reduce
						For x_table : x.sql_tables, acc_table : acc, name : Name
							Select name : (x_table ?? acc_table) Enforce Str
					With acc : {}
			# The tables that should be in the FROM of  the superquery
			exp_from : from {}
			requested_tables : For t : exp_from Select GenerateId t : t
			# The tables that the subquery actually uses from the superquery
			sql_tables :
				For t : total_tables, r : requested_tables, n : Name
					Where !(t Is Null) && (r Is Null)
					Select n : t
			# The tables that are used by the subquery and should remain bound
			tables :
				For t : total_tables, r : requested_tables, n : Name
					Where !(t Is Null) && !(r Is Null)
					Select n : t

			from_clause : For t : tables Concat t With ", "
			# Total aggregated tables
			total_aggregated_tables :
				For x : [result] Append exp_where Append exp_group
					Reduce
						For x_table : x.sql_aggregated_tables, acc_table : acc, name : Name
							Select name : (x_table ?? acc_table) Enforce Str
					With acc : {}

			sql_aggregated_tables :
				For t : total_aggregated_tables, r : requested_tables, n : Name
					Where !(t Is Null) && (r Is Null)
					Select n : t

			# GROUP BY clause
			exp_group : ({ value : group_by {}  sql_aggregate_context : "GROUP BY" }).value
			sql_group_cols :
				For x : exp_group
					Reduce For acc_cols : acc, x_cols : x.sql_non_aggregate_columns, name : Name Select name : acc_cols ?? x_cols
					With acc : {}

			total_non_aggregated_columns :
				For x : [result] Append exp_where
					Reduce
						For x_col : x.sql_non_aggregate_columns, acc_col : acc, name : Name
							Select name : (x_col ?? acc_col) Enforce Frame
					With acc : {}

			sql_non_aggregate_columns :
				For col : total_non_aggregated_columns, n : Name
					Where (For t : col.sql_tables, s : sql_tables Reduce acc || !(s Is Null) && !(t Is Null) With acc : False)
					Select n : col

			sql_non_aggregate_result_cols :
				For g : sql_group_cols, a : total_non_aggregated_columns, n : Name
					Where !(a Is Null) && (For t : a.sql_tables, s : sql_tables Reduce acc || (s Is Null) && !(t Is Null) With acc : False)
					Select n : g

			ungrouped_aggregate_cols :
				(For group : sql_group_cols, result : sql_non_aggregate_result_cols
					Where group Is Null
					Reduce result
					With " ") ?? ""

			group_clause :
				If (For s : sql_results_contain_aggregate Count) > 0 && Length (ungrouped_aggregate_cols Enforce Str) > 0
					Then Error ("The following columns are not grouped:" & ungrouped_aggregate_cols)
					Else
						(For clause : exp_group, position : Ordinal
							Reduce (If position > 1 Then acc & ", " Else " GROUP BY ") & clause.sql_expr
							With acc : "")
			group_parameters : For clause : exp_group Reduce acc Append clause.sql_parameters With acc : []
			# Query itself
			sql_type : result.sql_type
			sql_expr : "(SELECT \(result.sql_expr Enforce Str)" & (If from_clause Is Null Then provider.null_from Else " FROM " & from_clause Enforce Str) & where_clause Enforce Str & group_clause Enforce Str & ")"
			sql_parameters : result.sql_parameters Append where_parameters Append group_parameters
		}
		sum : Template base_aggregate_func_tmpl {
			sql_func : "SUM"
			sql_allowed_arg_type_mask : sql_types.numeric
		}
		time_constant : Template base_const_tmpl {
			{{{The Flabbergast frame containing the time.}}}
			arg : Required
			sql_type : sql_types.timestamp
		}
		unequal : Template base_compare_op_tmpl {
			sql_op : "<>"
		}
		upper : Template base_unary_function_tmpl {
			sql_arg_type : sql_types.str
			sql_type : sql_types.str
			sql_func : "UPPER"
		}
	}
	escape : utils_lib.str_concatifier(base : utils_lib.str_escape_builder(args : transformations), delimiter : "")
	escape_symbol : utils_lib.str_concatifier(base : utils_lib.str_escape_builder(args : symbol_transformations), delimiter : "")
}
sql_provider_with_union_literal : Template sql_provider {
	generate_literal_from : Template {
		value_list :
			For row : marshalled_rows, pos : Ordinal
				Concat
					"SELECT " & (For column : row, type : column_types, name : Name
						Concat (column?.sql_expr ?? "NULL") & " AS " & symbol_start Enforce Str & name & symbol_end Enforce Str
						With ",") & provider.null_from Enforce Str
				With " UNION "
		value : "(" & value_list Enforce Str & ") AS " & symbol_start Enforce Str & table_name Enforce Str & symbol_end Enforce Str
	}
}
sql_providers : {
	mssql : Template sql_provider {
		table_discovery +: {
			sql_query : "SELECT QUOTENAME(table_schema) + '.' + QUOTENAME(table_name) AS sql_from, QUOTENAME(table_schema, '''') as table_schema, QUOTENAME(table_name, '''') AS table_name, LOWER(LEFT(table_schema, 1)) + RIGHT(table_schema, LEN(table_schema) - 1) + '_' + table_name AS [] FROM information_schema.tables WHERE UPPER(table_schema) NOT IN ('SYS', 'INFORMATION_SCHEMA') AND PATINDEX('%[^a-zA-Z0-9_]%', table_schema) = 0 AND PATINDEX('%[^a-zA-Z0-9_]%', table_name) = 0;"
		}
		column_discovery +: {
			sql_query : "SELECT QUOTENAME(table_schema) + '.' + QUOTENAME(table_name) + '.' + QUOTENAME(column_name) AS sql_expr, QUOTENAME(column_name) AS sql_column, LOWER(LEFT(column_name, 1)) + RIGHT(column_name, LEN(column_name) - 1) AS [], data_type, 'sql_types.' + data_xlate.lookup AS [$sql_type] FROM information_schema.columns, (VALUES ('bigint', 'int'), ('decimal', 'int'), ('int', 'int'), ('money', 'int'), ('numeric', 'int'), ('smallint', 'int'), ('smallmoney', 'int'), ('tinyint', 'int'), ('bit', 'bool'), ('float', 'float'), ('real', 'float'), ('%char%', 'str'), ('%text%', 'str'), ('%binary%', 'str'), ('%datetime%', 'timestamp'), ('time%', 'timestamp'), ('date', 'timestamp'), ('%binary', 'blob')) AS data_xlate (name, lookup) WHERE table_schema = \(table.table_schema) AND table_name = \(table.table_name) AND data_type LIKE data_xlate.name AND PATINDEX('%[^a-zA-Z0-9_]%', column_name) = 0;"
		}
		quote_start : "('"
		quote_end : "')"
		symbol_start : "["
		symbol_end : "]"
		casting_name +: {
			blob : "VARBINARY(MAX)"
		}
		transformations : {
			quote : utils_lib.str_transform.char_tmpl { char : "'"  replacement : "''" }
			nonprint : utils_lib.str_transform.range_tmpl { start : "\x00"  end : "\x1F"  replacement : [ "' + NCHAR(", utf8_0, ") + '" ] }
			unicode : utils_lib.str_transform.range_tmpl { start : "\u0100"  end : "\uFFFF"  replacement : [ "' + NCHAR(", utf32, ") + '" ]  mode : mode_decimal }
		}
		symbol_transformations : {
			quote : utils_lib.str_transform.char_tmpl { char : "]"  replacement : "]]" }
		}
		allowed_expressions +: {
			extract +: {
				year : "year"
				month : "month"
				day : "day"
				hour : "hour"
				minute : "minute"
				second : "second"
				sql_start : "DATEPART('"
				sql_middle : "', "
				sql_end : ")"
			}
			interval_const +: {
				sql_expr : time Enforce Int
			}
			str_agg +: {
				sql_func : Null
				sql_extra_args : Error "String aggregation is not supported on Microsoft SQL Server/T-SQL."
			}
			str_join : Template base_variadic_func_tmpl {
				sql_func : "CONCAT"
				sql_allowed_arg_type_id : sql_types.str.id
			}
			str_slice +: {
				sql_substr_syntax : "SUBSTRING(" & specials.i.sql_expr & ", " & specials.s.sql_expr & ", " & specials.l.sql_expr & ")"
			}
			now +: {
				sql_expr : If utc Then "GETUTCDATE()" Else "CURRENT_TIMESTAMP"
			}
			time_constant +: {
				sql_expr : "DATEADD(SECOND,\(arg.epoch To Int), CONVERT(VARCHAR(30), '1970-01-01 00:00:00 Z') AS 'DATETIMEOFFSET')"
			}
		}
		sql_arithmetic_rules : {
			Attribute(sql_types.timestamp.id) : {
				Attribute(sql_types.interval.id) : {
					Attribute(sql_arith_ops.add.id B| sql_arith_ops.sub.id) : Template {
						result_type : Now sql_types.timestamp
						value : "DATEADD('second', 0 " & sql_op.symbol Enforce Str & specials.r.sql_expr Enforce Str & ", " & specials.l.sql_expr Enforce Str & ")"
					}
				}
				Attribute(sql_types.timestamp.id) : {
					Attribute(sql_arith_ops.sub.id) : Template {
						result_type : Now sql_types.interval
						value : "DATEDIFF('second', " & specials.l.sql_expr Enforce Str & ", " & specials.r.sql_expr Enforce Str & ")"
					}
				}
			}
		}
	}
	mysql : Template sql_provider_with_union_literal {
		table_discovery +: {
			sql_query : "SELECT QUOTE(TABLE_SCHEMA) AS tbl_schema, QUOTE(TABLE_NAME) AS tbl_name, CONCAT('`', TABLE_SCHEMA, '`.`', TABLE_NAME, '`') AS sql_from, CONCAT(LOWER(SUBSTRING(TABLE_NAME, 0, 1)), SUBSTRING(TABLE_NAME, 1)) AS ATTRNAME FROM information_schema.tables WHERE TABLE_SCHEMA NOT IN ('information_schema', 'performance_schema')"
		}
		column_discovery +: {
			sql_query : "SELECT CONCAT('`', TABLE_SCHEMA, '`.`', TABLE_NAME, '`.`', COLUMN_NAME, '`') AS sql_expr, CONCAT(LOWER(SUBSTRING(COLUMN_NAME, 1, 1)), SUBSTRING(COLUMN_NAME, 2)) AS ATTRNAME, lookup AS `$sql_type` FROM information_schema.COLUMNS, (SELECT 'bit%' AS type_pattern, 'sql_types.bool' AS lookup UNION SELECT '%int%' AS type_pattern, 'sql_types.int' AS lookup UNION SELECT 'float%' AS type_pattern, 'sql_types.float' AS lookup UNION SELECT 'double%' AS type_pattern, 'sql_types.float' AS lookup UNION SELECT 'decimal%' AS type_pattern, 'sql_types.float' AS lookup UNION SELECT '%char%' AS type_pattern, 'sql_types.str' AS lookup UNION SELECT '%blob%' AS type_pattern, 'sql_types.str' AS lookup UNION SELECT 'enum%' AS type_pattern, 'sql_types.str' AS lookup UNION SELECT 'text' AS type_pattern, 'sql_types.str' AS lookup UNION SELECT 'date' AS type_pattern, 'sql_types.timestamp' AS lookup UNION SELECT 'time%' AS type_pattern, 'sql_types.timestamp' AS lookup UNION SELECT 'year%' AS type_pattern, 'sql_types.timestamp' AS lookup UNION SELECT 'interval%' AS type_pattern, 'sql_types.interval' AS lookup UNION SELECT 'varbinary%' AS type_pattern, 'sql_types.blob' AS lookup UNION SELECT 'blob%' AS type_pattern, 'sql_types.blob' AS lookup) AS type_info WHERE COLUMN_TYPE LIKE type_pattern AND TABLE_SCHEMA=\(table.tbl_schema) AND TABLE_NAME=\(table.tbl_name)"
		}
		transformations : {
			backslash : utils_lib.str_transform.char_tmpl { char : "\\"  replacement : "\\\\" }
			backspace : utils_lib.str_transform.char_tmpl { char : "\b"  replacement : "\\b" }
			newline : utils_lib.str_transform.char_tmpl { char : "\n"  replacement : "\\n" }
			null : utils_lib.str_transform.char_tmpl { char : "\x00"  replacement : "\\0" }
			return : utils_lib.str_transform.char_tmpl { char : "\r"  replacement : "\\r" }
			quote : utils_lib.str_transform.char_tmpl { char : "'"  replacement : "\\'" }
			double_quote : utils_lib.str_transform.char_tmpl { char : "\""  replacement : "\\\"" }
			tab : utils_lib.str_transform.char_tmpl { char : "\t"  replacement : "\\t" }
			eof : utils_lib.str_transform.char_tmpl { char : "\x1A"  replacement : "\\Z" }
		}
		symbol_transformations : {
			quote : utils_lib.str_transform.char_tmpl { char : "`"  replacement : "``" }
		}
		symbol_start : "`"
		symbol_end : "`"
		casting_name +: {
			int : "SIGNED"
			str : "VARCHAR(4096)"
		}
		allowed_expressions +: {
			interval_const +: {
				sql_expr : "INTERVAL \(time Enforce Int) SECONDS"
			}
			now +: {
				sql_expr : If utc Then "UTC_TIMESTAMP()" Else "NOW()"
			}
			str_agg +: {
				sql_func : "GROUP_CONCAT"
				sql_extra_args : " SEPARATOR " & specials.s.sql_expr
			}
			str_join : Template base_variadic_func_tmpl {
				sql_func : "CONCAT"
				sql_allowed_arg_type_id : sql_types.str.id
			}
			time_constant +: {
				sql_expr : "TIMESTAMPADD(SECOND, \(arg.epoch To Int) + TIME_TO_SEC(TIMEDIFF(TIMESTAMP '1970-01-01 00:00:00',CONVERT_TZ('1970-01-01 00:00:00',@@session.time_zone,'+00:00'))),TIMESTAMP '1970-01-01 00:00:00')"
			}
		}
		sql_arithmetic_rules : {
			Attribute(sql_types.timestamp.id) : {
				Attribute(sql_types.timestamp.id) : {
					Attribute(sql_arith_ops.sub.id) : Template {
						result_type : Now sql_types.interval
						value : "TIMESTAMPDIFF(SECOND, " & specials.l.sql_expr Enforce Str & ", " & specials.r.sql_expr Enforce Str & ")"
					}
				}
				Attribute(sql_types.interval.id) : {
					Attribute(sql_arith_ops.add.id B| sql_arith_ops.sub.id) : Template {
						result_type : Now sql_types.timestamp
						value : "TIMESTAMPADD(SECOND, " & sql_op.symbol Enforce Str & specials.r.sql_expr Enforce Str & ", " & specials.l.sql_expr & ")"
					}
				}
			}
		}
	}
	oracle : Template sql_provider_with_union_literal {
		table_discovery +: {
			sql_query : "SELECT '\"' || table_name || '\"' AS \"sql_from\", table_name AS \"table_name\", REGEXP_REPLACE(REGEXP_REPLACE(LOWER(table_name), '[^a-zA-Z0-9_]', '_'), '^([^a-z])', 't\\1') AS \"ATTRNAME\" FROM user_tables"
		}
		column_discovery +: {
			sql_query : "SELECT '\"' || table_name || '\".\"' || column_name || '\"' AS \"sql_expr\", '\"' || column_name || '\"' AS \"sql_column\", REGEXP_REPLACE(REGEXP_REPLACE(LOWER(column_name), '[^a-zA-Z0-9_]', '_'), '^([^a-z])', 'c\\1') AS \"ATTRNAME\", data_type, 'sql_types.' || data_xlate.lookup AS \"\" FROM USER_TAB_COLUMNS , (SELECT objectschema name, objectname lookup FROM TABLE(sys.ODCIObjectList(sys.odciobject('NUMBER%', 'float'), sys.odciobject('%CHAR%', 'str'), sys.odciobject('BINARY_FLOAT', 'float'), sys.odciobject('BINARY_DOUBLE', 'float'), sys.odciobject('DATE%', 'timestamp'), sys.odciobject('TIMESTAMP%', 'timestamp'), sys.odciobject('INTERVAL%', 'interval'), sys.odciobject('%LOB', 'blob'), sys.odciobject('BFILE', 'blob')))) data_xlate WHERE table_name = '\(table_name)'  AND data_type LIKE data_xlate.name"
		}
		transformations : {
			quote : utils_lib.str_transform.char_tmpl { char : "'"  replacement : "''" }
		}
		symbol_transformations : {
			quote : utils_lib.str_transform.char_tmpl { char : "\""  replacement : "\"\"" }
		}
		null_from : " FROM DUAL"
		allowed_expressions +: {
			interval_const +: {
				sql_expr : "INTERVAL '\(time Enforce Int)' SECOND"
			}
			now +: {
				sql_expr : If utc Then "SYS_EXTRACT_UTC(CURRENT_TIMESTAMP)" Else "CURRENT_TIMESTAMP"
			}
			str_agg +: {
				sql_func : "LISTAGG"
				sql_extra_args : ", " & specials.s.sql_expr & ") WITHIN GROUP (ORDER BY " & arg.sql_expr
			}
			str_slice +: {
				sql_substr_syntax : "SUBSTR(" & specials.i.sql_expr & ", " & specials.s.sql_expr & ", " & specials.l.sql_expr & ")"
			}
			time_constant +: {
				sql_expr : "(TIMESTAMP '1970-01-01 00:00:00 UTC' + NUMTODSINTERVAL(\(arg.epoch To Int), 'SECOND'))"
			}
		}
		generate_literal_from +: {
			value : "(" & value_list Enforce Str & ") " & symbol_start Enforce Str & table_name Enforce Str & symbol_end Enforce Str
		}
	}
	postgresql : Template sql_provider {
		table_discovery +: {
			sql_query : "SELECT QUOTE_IDENT(table_schema) || '.' || QUOTE_IDENT(table_name) AS sql_from, QUOTE_LITERAL(table_schema) AS table_schema, QUOTE_LITERAL(table_name) AS table_name, regexp_replace(regexp_replace(table_schema || '_' || table_name, '[^a-zA-Z0-9_]', '_'), '^([^a-z])', 't\\1') AS \"ATTRNAME\" FROM information_schema.tables WHERE table_schema NOT IN ('pg_catalog', 'information_schema');"
		}
		column_discovery +: {
			sql_query : "SELECT QUOTE_IDENT(table_schema) || '.' || QUOTE_IDENT(table_name) || '.' || QUOTE_IDENT(column_name) AS sql_expr, QUOTE_IDENT(column_name) AS sql_column, regexp_replace(regexp_replace(column_name, '[^a-zA-Z0-9_]', '_'), '^([^a-z])', 'c\\1') AS \"ATTRNAME\", data_type, 'sql_types.' || data_xlate.lookup AS \"$sql_type\" FROM information_schema.columns, (VALUES ('bigint', 'int'), ('bigserial', 'int'), ('integer', 'int'), ('interval%', 'int'), ('serial', 'int'), ('smallint', 'int'), ('boolean', 'bool'), ('numeric%', 'float'), ('double precision', 'float'), ('real', 'float'), ('bytea', 'str'), ('character%', 'bool'), ('text', 'str'), ('date', 'timestamp'), ('time%', 'timestamp'), ('interval%', 'interval'), ('bytea', 'blob') AS data_xlate (name, lookup) WHERE table_schema = \(table.table_schema) AND table_name = \(table.table_name) AND data_type LIKE data_xlate.name"
		}
		quote_start : "E'"
		blob_start : "E'\\x"
		casting_name +: {
			blob : "bytea"
		}
		transformations : {
			backslash : utils_lib.str_transform.char_tmpl { char : "\\"  replacement : "\\\\" }
			backspace : utils_lib.str_transform.char_tmpl { char : "\b"  replacement : "\\b" }
			formfeed : utils_lib.str_transform.char_tmpl { char : "\f"  replacement : "\\f" }
			newline : utils_lib.str_transform.char_tmpl { char : "\n"  replacement : "\\n" }
			null : utils_lib.str_transform.char_tmpl { char : "\x00"  replacement : "\\0" }
			quote : utils_lib.str_transform.char_tmpl { char : "'"  replacement : "\\'" }
			tab : utils_lib.str_transform.char_tmpl { char : "\t"  replacement : "\\t" }
			nonprint : utils_lib.str_transform.range_tmpl { start : "\x00"  end : "\x1F"  replacement : [ "\\x", utf8_0 ] }
			unicode : utils_lib.str_transform.range_tmpl { start : "\u0100"  end : "\uFFFF"  replacement : [ "\\U", utf32]  mode : mode_hex_upper }
		}
		symbol_transformations : {
			quote : utils_lib.str_transform.char_tmpl { char : "\""  replacement : "\"\"" }
		}
		allowed_expressions +: {
			interval_const +: {
				sql_expr : "INTERVAL '\(time Enforce Int)' SECONDS"
			}
			now +: {
				sql_expr : "(NOW() \(If utc Then "AT TIME ZONE 'utc'" Else ""))"
			}
			str_agg +: {
				sql_func : "STRING_AGG"
				sql_extra_args : ", " & specials.s.sql_expr
			}
			time_constant +: {
				sql_expr : "TIMESTAMP 'epoch' + \(arg.epoch To Int) * INTERVAL '1 second'"
			}
		}
	}
	sqlite : Template sql_provider_with_union_literal {
		table_discovery +: {
			sql_query : "SELECT name AS \"ATTRNAME\", tbl_name AS sql_from FROM sqlite_master WHERE type = 'table'"
		}
		column_discovery +: {
			sql_query : "PRAGMA table_info(\"\(table.sql_from)\")"
			# SQLite doesn't give us the power to control the format of the data we
			# get back, so we get to do it locally. Fun.
			value +orig:
				For col : orig
					Select col.name : col
			sql_row_tmpl +: {
				sql_expr : "\"\(table.sql_from)\".\"\(name)\""
				sql_column : "\"\(name)\""
				sql_type :
					If type Is Null Then sql_types.str
					Else If
						type == "BOOLEAN" Then sql_types.bool
					Else If
						type == "INT" ||
						type == "INTEGER" ||
						type == "TINYINT" ||
						type == "SMALLINT" ||
						type == "MEDIUMINT" ||
						type == "BIGINT" ||
						type == "UNSIGNED BIG INT" ||
						type == "INT2" ||
						type == "INT8" Then sql_types.int
					Else If
						type == "REAL" ||
						type == "DOUBLE" ||
						type == "DOUBLE PRECISION" ||
						type == "FLOAT" Then sql_types.float
					Else If
						type == "BLOB" Then sql_types.blob
					Else sql_types.str
			}
		}
		transformations : {
			# This is kind of scary, but what's actually listed in the SQL92 spec and
			# the SQLite tokenizer. It's unclear how it will deal with UTF-8
			# surrogate pairs.
			quote : utils_lib.str_transform.char_tmpl { char : "'"  replacement : "''" }
		}
		symbol_transformations : {
			quote : utils_lib.str_transform.char_tmpl { char : "\""  replacement : "\"\"" }
		}
		allowed_expressions +: {
			interval_const +: {
				sql_expr : time Enforce Int
			}
			extract +: {
				year : "Y"
				month : "m"
				day : "d"
				hour : "H"
				minute : "M"
				second : "s"
				sql_start : "CAST(STRFTIME('%"
				sql_middle : "', "
				sql_end : ") AS INTEGER)"
			}
			now +: {
				sql_expr : "DATETIME('now', '\(If utc Then "utc" Else "localtime")')"
			}
			str_agg +: {
				sql_func : "GROUP_CONCAT"
				sql_extra_args : ", " & specials.s.sql_expr
			}
			str_slice +: {
				sql_substr_syntax : "SUBSTR(" & specials.i.sql_expr & ", " & specials.s.sql_expr & ", " & specials.l.sql_expr & ")"
			}
			time_constant +: {
				sql_expr : "DATETIME(\(arg.epoch To Int), 'unixepoch', 'utc')"
			}
		}
		sql_arithmetic_rules : {
			Attribute(sql_types.timestamp.id) : {
				Attribute(sql_types.timestamp.id) : {
					Attribute(sql_arith_ops.sub.id) : Template {
						result_type : Now sql_types.interval
						value : "(STRFTIME('%s', " & specials.l.sql_expr Enforce Str & ") - STRFTIME('%s', " & specials.r.sql_expr Enforce Str & "))"
					}
				}
				Attribute(sql_types.interval.id) : {
					Attribute(sql_arith_ops.add.id B| sql_arith_ops.sub.id) : Template {
						result_type : Now sql_types.timestamp
						value : "DATETIME(" & specials.l.sql_expr & ", '" & sql_op.symbol Enforce Str & "' || " & specials.r.sql_expr Enforce Str & " || ' seconds')"
					}
				}
			}
		}
	}
}

{{{The default row template is empty, providing only the columns in the database.}}}
sql_row_tmpl : Template {}
