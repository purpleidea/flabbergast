'\" t
.\" Authors: Andre Masella
.TH flabbergast 7 "Oct 2017" "1.0" "MISCELLANEOUS"
.SH NAME
flabbergast_language \- The definition of the Flabbergast language
.ds < \v'0.4m'\x'\\n(0x=0*0.2m'\s-3
.ds > \s0\v'-0.4m'
.SH SYNOPSIS
Flabbergast is a language for creating configuration structures that can be rendered to a final configuration. Each expression is side-effect free. It has unusual look-up semantics, explained below.

This document is the formal specification for the language. Fundamentally, there are three important types of values in the language: frames, key-value pairs; templates, key-template pairs; and scalar values. There is an import mechanism that functions are the foreign function interface of the language. Each frame and template has an associated lookup environment, which is an ordered list of frames.

There are several important features of the language:
.IP \[bu]
contextual lookup creates dynamic scoping
.IP \[bu]
values have scope, expressions do not. This an effect of contextual lookup.
.IP \[bu]
inheritance can be changed. That is, a frame can extend another frame, but this cannot be known at compile-time. This an effect of contextual lookup.

.SH GENERAL NOTES ON SYNTAX
In the language, language-defined names, a.k.a. keywords, are of the format [\fBA\fR-\fBZ\fR][\fBA\fR-\fBZa\fR-\fBz\fR]*. All user-defined names, a.k.a. identifiers, are of the form [\fBa\fR-\fBz\fR][\fBA\fR-\fBZa\fR-\fBz0\fR-\fB9_\fR]*. There are other symbols in the language, all of them ASCII. Strings and comments may contain Unicode data.

No keyword defined in this specification will ever begin with X. Implementation-specific keywords for debugging are permissible if they begin with X.

Future versions may extend the keyword system to Unicode.

.SH TYPES IN THE LANGUAGE
.TP
Bin
a byte string
.TP
Bool
a Boolean value. Maybe either \fBTrue\fR or \fBFalse\fR.
.TP
Float
IEEE floating point number
.TP
Frame
a mapping from strings and integers to values, which are of the types mentioned in this section. No duplicate identifiers are permitted (i.e., the identifier space is a set).
.TP
Int
platform-specific integral number
.TP
LookupHandler
an algorithm for doing lookup
.TP
Unit
the type of the \fBNull\fR value.
.TP
Str
a Unicode text string
.TP
Template
a mapping from strings and integers to expressions. No duplicate identifiers are permitted (i.e., the identifier space is a set).

.SH GRAMMAR AND SEMANTICS
Line-terminated comments may start with \fB#\fR. The grammar is a PEG, so assume that low precedence rules are shown first.

For convenience of writing, expression are broken into groups, based on precedence. It can be assumed that the PEG expression for group \fIx\fR, with expressions \fIA\fR, \fIB\fR, ... is

.RS
E\*<\fIx\fR\*> = \fIA\fR / \fIB\fR / E\*<\fIx+1\fR\*>
.RE

If unspecified, assume E\*<\fIx\fR\*>. The rule E\*<\fI+\fR\*> is short-hand for E\*<\fIx+1\fR\*>.

Literal values that must be matched exactly, including keywords, are written in \fBthis type-face\fR. Any space can be a combination of any Unicode space or comments. Other rules are referenced with a preceding name for the result (e.g., a:E parses and expression E and it is referred to in the accompanying text and semantics as a).

For the semantics, they are written as a Horn clause of the form:

.de SEM
.HP
.B Definition:
\\$* :-
.br
.in +0.5i
..
.de SEME
.in
..
.RS
(\fIT\fR\*<0\*>*, \fIT\fR\*<1\*>, ...) ⊢ \fIexpr\fR ↓ value :: type :- ...
.RE

where \fIT\fR is a frames used for lookup. Some frames are marked with an * to change lookup semantics. If the lookup environment is unused, it is elided. If the type is implied, it is elided.

Since frames and templates are manipulated by the language, their values have special representation. A frame is written < u; Γ; k\*<a\*> → v\*<a\*>, k\*<b\*> → v\*<b\*>, ... >. It is implied that there are no two values of \fIk\fR that exist in the same frame. A template is written < Γ; k\*<a\*> → e\*<a\*>, k\*<b\*> → e\*<b\*>, ... >. Again, it is implied that there are no duplicate \fIk\fR. Since both frames and templates have a key space that is a set, it is reasonable to allow all normal set operations over them. Since the contents of a frame or template indicate what it it is, the type can be elided. Both have context information, Γ, which is a list of frames for resolution. Frames also contain a unique identifier, \fIu\fR, which is a string such that no two frames in the program have the same identifier.

.SS FILE FRAME (START)
The top-level entity is a file frame.

.SEM a:(A*) ↓ x
() ⊢  \fB{\fR a \fB}\fR ↓ x
.SEME

.SS EXPRESSION SYNTAX (E) – NAME BINDING
.TP
Bind a new name

.SEM (t, ...) ⊢ \fBLet\fR name:I \fB:\fR nameexpr:E\*<0\*> (\fB,\fR name:I \fB:\fR nameexpr:E\*<0\*> )* \fBIn\fR expr:E ↓ v
∀ nameexpr : Γ ⊢ nameexpr ↓ v\*<nameexpr\*>,

(< u; (t, ...); ∀ name, nameexpr : name → v\*<nameexpr\*> >*, t, ...) ⊢ expr ↓ v
.SEME

.SS EXPRESSION SYNTAX (E) – FRICASSÉE
.TP
Fricassée a frame (a.k.a. \fBFor\fR expressions)

.SEM Γ ⊢ \fBFor\fR s:FS r:FR ↓ v
Γ ⊢ s ↓ W,

Γ; W ⊢ r ↓ v
.SEME

This operator allows iterating over the values in a frame to produce some new result. The syntax is handled in two pieces: a source component (FS) that creates a list of contexts, each being an environment in which the relevant values from the input are defined (i.e., it is a list of witnesses), a result component (FR) that evaluates expressions using the witnesses and produces a result.

Some sources may be chained together to manipulate the list of contexts. There are two kinds of result components: order-sensitive (S) and order-insensitive (I). Order insensitive results will not depend on the order in which contexts are provided while order sensitive ones will produce different output depending on order. All sources implicitly produce some order, but there are three kinds: independent (=), where each context is treated in isolation; implicitly order-generating (G), where there is an order to the contexts, but it was not explicitly defined by the user; and user-defined order-generating (U), where the order is implied by the user. Not all chains of sources are valid. Specifically, any chain that matches U=*I is invalid.

For an example, consider:

\fBFor x : xs, n : Name Order By x Enforce Int Select n : x\fR [GUI]

Here, the \fBOrder By\fR operation's rearrangement is ignored by \fBSelect\fR. However, this is valid:

\fBFor x : xs, n : Name Order By x Enforce Int Reduce x * a With a : 1\fR [GUS]

Since the \fBReduce\fR result is order-sensitive. Some intermediate operations affect this behaviour. The following is invalid:

\fBFor x : xs, n : Name Order By x Enforce Int Where x > 5 Select n : x\fR [GU=I]

since the additional \fBWhere\fR clause does not examine the order. However, the following is valid:

\fBFor x : xs, n : Name Order By x Enforce Int Skip x < 5 Select n : x\fR [GUGI]

since \fBSkip\fR examines the order produced by \fBOrder By\fR.


.SS EXPRESSION SYNTAX (E) – CONDITITONAL
.TP
Conditional

.SEM Γ ⊢ \fBIf\fR cond:E\*<0\*> \fBThen\fR true:E\*<0\*> \fBElse\fR false:E ↓ x
Γ ⊢ cond ↓ True,

Γ ⊢ true ↓ x
.SEME

.SEM Γ ⊢ \fBIf\fR cond:E\*<0\*> \fBThen\fR true:E\*<0\*> \fBElse\fR false:E ↓ x
Γ ⊢ cond ↓ False,

Γ ⊢ false ↓ x
.SEME

Computes the \fIcond\fR and, if boolean, returns \fItrue\fR or \fIfalse\fR depending on the value. Otherwise, an error. The expression which is not selected is not evaluated.

.SS EXPRESSION SYNTAX (E) – CONCATENATION
.TP
Concatenate two strings
.SEM Γ ⊢ a:E\*<+\*> \fB&\fR b:E ↓ \(dqxy\(dq
Γ ⊢ a \fBTo Str\fR ↓ \(dqx\(dq :: Str,

Γ ⊢ b \fBTo Str\fR ↓ \(dqy\(dq :: Str
.SEME

.TP
Concatenate two frames
.SEM (s, ...) ⊢ a:E\*<+\*> \fBAppend\fR b:E ↓ t = < u; (t, s, ...); x → av\*<x\*>, (|at| + y) → bv\*<y\*> >
(s, ...) ⊢ a ↓ at = < ac; ae; ak\*<x\*> → av\*<x\*> >,

(s, ...) ⊢ b ↓ < bc; be; bk\*<y\*> → bv\*<y\*> >,

(s, ...) ⊢ \fBThis\fR ↓ u

.SEME

.SS EXPRESSION SYNTAX (E) – DISJUNCTION
.TP
Logical disjunction (short circuiting)

.SEM Γ ⊢ a:E\*<+\*> \fB||\fR b:E ↓ True
Γ ⊢ a ↓ True
.SEME

.SEM Γ ⊢ a:E\*<+\*> \fB||\fR b:E ↓ v
Γ ⊢ a ↓ False,

Γ ⊢ b ↓ v :: Bool
.SEME

.SS EXPRESSION SYNTAX (E) – CONJUNCTION
.TP
Logical intersection (short circuiting)
expr \fB&&\fR expr

.SEM Γ ⊢ a:E\*<+\*> \fB&&\fR b:E ↓ False
Γ ⊢ a ↓ False
.SEME

.SEM Γ ⊢ a:E\*<+\*> \fB&&\fR b:E ↓ v
Γ ⊢ a ↓ True,

Γ ⊢ b ↓ v :: Bool
.SEME

.SS EXPRESSION SYNTAX (E) – COMPARISON

.TP
Equality check
.SEM Γ ⊢ a:E\*<+\*> \fB==\fR b:E\*<+\*> ↓ True
Γ ⊢ a \fB<=>\fR b ↓ 0 :: Int
.SEME

.SEM Γ ⊢ a:E\*<+\*> \fB==\fR b:E\*<+\*> ↓ False
Γ ⊢ a \fB<=>\fR b ↓ x :: Int,
x ≠ 0
.SEME

.TP
Inequality check
.SEM Γ ⊢ a:E\*<+\*> \fB!=\fR b:E\*<+\*> ↓ False
Γ ⊢ a \fB<=>\fR b ↓ 0 :: Int
.SEME

.SEM Γ ⊢ a:E\*<+\*> \fB!=\fR b:E\*<+\*> ↓ True
Γ ⊢ a \fB<=>\fR b ↓ x :: Int,

x ≠ 0
.SEME

.TP
Greater than check
.SEM Γ ⊢ a:E\*<+\*> \fB>\fR b:E\*<+\*> ↓ True
Γ ⊢ a \fB<=>\fR b ↓ 1 :: Int
.SEME

.SEM Γ ⊢ a:E\*<+\*> \fB>\fR b:E\*<+\*> ↓ False
Γ ⊢ a \fB<=>\fR b ↓ x :: Int,

x ≠ 1
.SEME

.TP
Greater than or equal to check

.SEM Γ ⊢ a:E\*<+\*> \fB>=\fR b:E\*<+\*> ↓ False
Γ ⊢ a \fB<=>\fR b ↓ -1 :: Int
.SEME

.SEM Γ ⊢ a:E\*<+\*> \fB>=\fR b:E\*<+\*> ↓ True
Γ ⊢ a \fB<=>\fR b ↓ x :: Int,

x ≠ -1
.SEME

.TP
Less than check
.SEM Γ ⊢ a:E\*<+\*> \fB<\fR b:E\*<+\*> ↓ True
Γ ⊢ a \fB<=>\fR b ↓ -1 :: Int
.SEME

.SEM Γ ⊢ a:E\*<+\*> \fB<\fR b:E\*<+\*> ↓ False
Γ ⊢ a \fB<=>\fR b ↓ x :: Int,

x ≠ -1
.SEME

.TP
Less than or equal to check

.SEM Γ ⊢ a:E\*<+\*> \fB<=\fR b:E\*<+\*> ↓ False
Γ ⊢ a \fB<=>\fR b ↓ 1 :: Int
.SEME

.SEM Γ ⊢ a:E\*<+\*> \fB<=\fR b:E\*<+\*> ↓ True
Γ ⊢ a \fB<=>\fR b ↓ x :: Int,

x ≠ 1
.SEME

.SS EXPRESSION SYNTAX (E) – ORDERING
.TP
Ordering operator
.SEM Γ ⊢ a:E\*<+\*> \fB<=>\fR b:E\*<+\*> ↓ z :: Int
Γ ⊢ a ↓ x :: Int ∨ Γ ⊢ a ↓ x :: Float,

Γ ⊢ b ↓ y :: Int ∨ Γ ⊢ b ↓ x :: Float,

z = sgnum(x - y)
.SEME

.SEM Γ ⊢ a:E\*<+\*> \fB<=>\fR b:E\*<+\*> ↓ 0 :: Int
Γ ⊢ a ↓ True,

Γ ⊢ b ↓ True
.SEME

.SEM Γ ⊢ a:E\*<+\*> \fB<=>\fR b:E\*<+\*> ↓ 0 :: Int
Γ ⊢ a ↓ False,

Γ ⊢ b ↓ False
.SEME

.SEM Γ ⊢ a:E\*<+\*> \fB<=>\fR b:E\*<+\*> ↓ -1 :: Int
Γ ⊢ a ↓ False,

Γ ⊢ b ↓ True
.SEME

.SEM Γ ⊢ a:E\*<+\*> \fB<=>\fR b:E\*<+\*> ↓ 1 :: Int
Γ ⊢ a ↓ True,

Γ ⊢ b ↓ False
.SEME

.SEM Γ ⊢ a:E\*<+\*> \fB<=>\fR b:E\*<+\*> ↓ UTS10(x, y) :: Int
Γ ⊢ a ↓ x :: Str,

Γ ⊢ b ↓ y :: Str
.SEME

Compares operands for ordering. It returns the integer -1 (left is before right), 0 (both equivalent), or 1 (right is before right) based on the operands. All combinations not listed are errors (this includes all comparisons with \fBNull\fR).

.TS
tab(;);
al;e.
\fBOperand Types;Behaviour\fR
Both str;T{
Collated the strings using Unicode Technical Standard 10.
T}
Both bool;T{
Compare where \fBFalse\fR < \fBTrue\fR.
T}
Both float;T{
Compare numerically. If either value is NaN, raise an error.
T}
Both int;T{
Compare numerically.
T}
One int, one float;T{
Upgrade the integer to a float and compare as floats.
T}
.TE

Note that string comparison is locale-dependent.

.SS EXPRESSION SYNTAX (E) – BIT-WISE DISJUNCTION
.TP
Bit-wise disjunction

.SEM Γ ⊢ a:E\*<+\*> \fBB|\fR b:E ↓ BITWISE_OR(v, w) :: Int
Γ ⊢ a ↓ v :: Int,

Γ ⊢ b ↓ w :: Int
.SEME

.SS EXPRESSION SYNTAX (E) – BIT-WISE SYMMETRIC DIFFERENCE
.TP
Bit-wise symmetric difference (exclusive or)

.SEM Γ ⊢ a:E\*<+\*> \fBB^\fR b:E ↓ BITWISE_XOR(v, w) :: Int
Γ ⊢ a ↓ v :: Int,

Γ ⊢ b ↓ w :: Int
.SEME

.SS EXPRESSION SYNTAX (E) – BIT-WISE CONJUNCTION
.TP
Bit-wise conjunction

.SEM Γ ⊢ a:E\*<+\*> \fBB&\fR b:E ↓ BITWISE_AND(v, w) :: Int
Γ ⊢ a ↓ v :: Int,

Γ ⊢ b ↓ w :: Int
.SEME

.SS EXPRESSION SYNTAX (E) – ARITHMETIC DISJUNCTION
.TP
Addition and Subtraction

.SEM Γ ⊢ a:E\*<+\*> o:(\fB+\fR / \fB-\fR) b:E\*<+\*> r:((\fB+\fR / \fB-\fR) E\*<+\*>)* ↓ z :: Int
Γ ⊢ a ↓ x :: Int,

Γ ⊢ b ↓ y :: Int,

w = O(x, y),

Γ ⊢ w r ↓ z
.SEME

.SEM Γ ⊢ a:E\*<+\*> o:(\fB+\fR / \fB-\fR) b:E\*<+\*> r:((\fB+\fR / \fB-\fR) E\*<+\*>)* ↓ z :: Float
Γ ⊢ a ↓ x :: Int ∨ Γ ⊢ a ↓ x :: Float,

Γ ⊢ b ↓ y :: Int ∨ Γ ⊢ b ↓ y :: Float,

w = O(x, y),

Γ ⊢ w r ↓ z
.SEME

.SS EXPRESSION SYNTAX (E) – ARITHMETIC CONJUNCTION
.TP
Multiplication, Division and Modulus

.SEM Γ ⊢ a:E\*<+\*> o:(\fB*\fR / \fB/\fR) b:E\*<+\*> r:((\fB*\fR / \fB/\fR) E\*<+\*>)+ ↓ z :: Int
Γ ⊢ a ↓ x :: Int,

Γ ⊢ b ↓ y :: Int,

w = O(x, y),

Γ ⊢ w r ↓ z
.SEME

.SEM Γ ⊢ a:E\*<+\*> o:(\fB*\fR / \fB/\fR / \fB%\fR) b:E\*<+\*> r:((\fB*\fR / \fB/\fR / \fB%\fR) E\*<+\*>)+ ↓ z :: Float
Γ ⊢ a ↓ x :: Int ∨ Γ ⊢ a ↓ x :: Float,

Γ ⊢ b ↓ y :: Int ∨ Γ ⊢ b ↓ y :: Float,
w = O(x, y),

Γ ⊢ w r ↓ z
.SEME

Where the \fIO\fR is multiplication for \fB*\fR, division for \fB/\fR, and modulus for \fB%\fR. In the integer case, these operations are carried out per C semantics. For the floating point case, these are carried out using IEEE-754, where modulus is equivalent to the C function \fBfmod\fR.

.SS EXPRESSION SYNTAX (E) – RANGE AND SHIFT
.TP
Range of integers
.SEM (t, ...) ⊢ start:E\*<+\*> \fBThrough\fR end:E\*<+\*> ↓ r = < u; r, t, ...; ∀ x ≥ s ∧ x ≤ e : x → x :: Int >
(t, ...) ⊢ start ↓ s :: Int,

(t, ...) ⊢ end ↓ e :: Int
.SEME

Produce a list of integers that counts from the value of \fIstart\fR up to and including \fIend\fR, both of which must be integers. If \fIend\fR is less than \fIstart\fR an empty list is produced.

.TP
Bit-wise shift
.SEM (t, ...) ⊢ value:E\*<+\*> \fBShift\fR offset:E\*<+\*> ↓ (v * 2 ** o) :: Int >
(t, ...) ⊢ value ↓ v :: Int,

(t, ...) ⊢ offset ↓ o :: Int
.SEME

Performs a bit-wise shift of the input. The offset may be negative, which cause loss of low-significance bits.

.SS EXPRESSION SYNTAX (E) – TYPE MANIPULATION

.TP
Coerce a value to the same type
.SEM Γ ⊢ expr:E\*<+\*> \fBTo\fR t ↓ v :: t
Γ ⊢ expr ↓ v :: t
.SEME

.TP
Coerce a value to a float
.SEM Γ ⊢ expr:E\*<+\*> \fBTo\fR \fBFloat\fR ↓ v :: Float
Γ ⊢ expr ↓ v :: Int
.SEME

.TP
Coerce a value to an integer
.SEM Γ ⊢ expr:E\*<+\*> \fBTo\fR \fBInt\fR ↓ ROUND_TOWARD_ZERO(v) :: Int
Γ ⊢ expr ↓ v :: Float
.SEME

See IEEE 754 for semantics of ROUND_TOWARD_ZERO (a.k.a., truncation).

.TP
Coerce a value to an string
.SEM Γ ⊢ expr:E\*<+\*> \fBTo\fR \fBStr\fR ↓ PRINTF(\(dq%d\(dq, v) :: Str
Γ ⊢ expr ↓ v :: Int
.SEME
.SEM Γ ⊢ expr:E\*<+\*> \fBTo\fR \fBStr\fR ↓ PRINTF(\(dq%f\(dq, v) :: Str
Γ ⊢ expr ↓ v :: Float
.SEME
.SEM Γ ⊢ expr:E\*<+\*> \fBTo\fR \fBStr\fR ↓ \(dqTrue\(dq :: Str
Γ ⊢ expr ↓ True
.SEME
.SEM Γ ⊢ expr:E\*<+\*> \fBTo\fR \fBStr\fR ↓ \(dqFalse\(dq :: Str
Γ ⊢ expr ↓ False
.SEME

PRINTF conforms to
.BR printf (3)
defined in C89.

.TP
Type enforcement.
.SEM Γ ⊢ expr:E\*<+\*> \fBEnforce\fR type:T ↓ v
Γ ⊢ expr ↓ v :: T
.SEME

Checks if a value has a particular type and returns the value. If it does not, an error occurs.

.TP
Type check
.SEM Γ ⊢ expr:E\*<+\*> \fBIs\fR type:T ↓ True
Γ ⊢ expr ↓ v :: type
.SEME

.SEM Γ ⊢ expr:E\*<+\*> \fBIs\fR type:T ↓ False
Γ ⊢ expr ↓ v :: t,

t ≠ type
.SEME

Returns \fBTrue\fR if the value has the correct type, \fBFalse\fR otherwise. Always returns \fBFalse\fR for \fBNull\fR values.

.TP
Checks if a number is finite
.SEM Γ ⊢ expr:E\*<+\*> \fBIs Finite\fR ↓ True
Γ ⊢ expr ↓ v :: Int
.SEME
.SEM Γ ⊢ expr:E\*<+\*> \fBIs Finite\fR ↓ ISFINITE(v) :: Bool
Γ ⊢ expr ↓ v :: Float
.SEME

If the value is a float, returns \fBFalse\fR if the value is infinite or not-a-number, \fBTrue\fR otherwise. If the value is an integer, returns \fBTrue\fR. See IEEE 754.

.TP
Check if a number is not-a-number.
.SEM Γ ⊢ expr:E\*<+\*> \fBIs NaN\fR ↓ False
Γ ⊢ expr ↓ v :: Int
.SEME
.SEM Γ ⊢ expr:E\*<+\*> \fBIs NaN\fR ↓ ISNAN(v) :: Bool
Γ ⊢ expr ↓ v :: Float
.SEME

If the value is a float, returns \fBTrue\fR if the value is not a number, \fBFalse\fR otherwise. If the value is an integer, returns \fBFalse\fR.

.TP
Checks if a value is \fBNull\fR.
.SEM Γ ⊢ expr:E\*<+\*> \fBIs Null\fR ↓ True
Γ ⊢ expr ↓ ∅
.SEME

.SEM Γ ⊢ expr:E\*<+\*> \fBIs Null\fR ↓ False
Γ ⊢ expr ↓ v :: t,

t ≠ Unit
.SEME

Returns \fBTrue\fR if the value is \fBNull\fR, \fBFalse\fR for all other values.

.SS EXPRESSION SYNTAX (E) – ERROR AND LENGTH
.TP
Raise an error
.SEM Γ ⊢ \fBError\fR expr:E\*<+\*>
Γ ⊢ expr \fBTo Str\fR ↓ m
.SEME

Returns the Unicode character count of the provided string.
.TP
String character length
.SEM Γ ⊢ \fBLength\fR expr:E\*<+\*> ↓ n :: Int
Γ ⊢ expr \fBTo Str\fR ↓ "c\*<1\*>c\*<2\*>...c\*<n\*>" :: Str
.SEME

Returns the number of bytes of the provided binary data.
.TP
Binary data length
.SEM Γ ⊢ \fBLength\fR expr:E\*<+\*> ↓ n :: Int
Γ ⊢ expr ↓ [[x\*<1\*>x\*<2\*>...x\*<n\*>]] :: Bin
.SEME

.SS EXPRESSION SYNTAX (E) – CUSTOM LOOKUP
.TP
Perform custom lookup.
.SEM Γ ⊢ \fBLookup\fR part:LN part:(\fB.\fRLN)* \fBUsing\fR lookup:E\*<0\*> source:LS ↓ v
Γ ⊢ lookup ↓ h :: LookupHandler,

Γ ⊢ part\*<i\*> ↓ name\*<i\*>,

Γ ⊢ source ↓ Δ,

Δ ⊢ h(name\*<1\*>, ...) ↓ v
.SEME

The algorithm by which the handler reduces names to a value is implementation defined. The \fBContextual\fR handler is defined in this document.

.TP
Perform contextual lookup in a custom environment.
.SEM Γ ⊢ \fBLookup\fR part:LN part:(\fB.\fRLN)* source:LS ↓ v
Γ ⊢ \fBLookup\fR part \fBUsing Contextual\fR source ↓ v
.SEME

.SS EXPRESSION SYNTAX (E) – INSTANTIATION
.TP
Instantiate a template

.SEM Γ ⊢ source:E\*<+\*> \fB{\fR a:(A / O / E)+ \fB}\fR ↓ v
Γ ⊢ \fB(Template\fR source \fB{\fR a \fB}) { }\fR ↓ v
.SEME

.SEM (t, ...) ⊢ source:E\*<+\*> \fB{ }\fR ↓ r = < u; r, t, ..., s, ...; ∀ x : k\*<x\*> → v\*<x\*> >
(t, ...) ⊢ source ↓ S = < (s, ...); k\*<s\*> → e\*<s\*>, ... >,

∀ k\*<x\*> → e\*<x\*> ∈ S : (r, t, ..., s, ...) ⊢ e\*<x\*> ↓ v\*<x\*>
.SEME

Creates a new frame, based on a template, grounded in the current scope. If source is a template, instantiate that template setting the provided attributes and inheriting any others. If source is not a template, an error occurs. If any attribute is external but not overridden, it will cause an error.

.SS EXPRESSION SYNTAX (E) – COALESCENCE
.TP
Null coalescence
.SEM Γ ⊢ value:E\*<+\*> \fB??\fR default:E\*<+\*> ↓ v
Γ ⊢ value ↓ v
.SEME

.SEM Γ ⊢ value:E\*<+\*> \fB??\fR default:E\*<+\*> ↓ v
Γ ⊢ value ↓ ∅,

Γ ⊢ default ↓ v
.SEME

.SS EXPRESSION SYNTAX (E) – FRAME CREATION, NULLABLE LOOKUP, AND UNARY OPERATORS
.TP
Literal frame
.SEM (t, ...) ⊢ \fB{\fR (a:A)* \fB}\fR ↓ r = < u; r, t, ...;  ∀ x ∈ a : k\*<x\*> → v\*<x\*> >

∀ x ∈ a : (t, ...); (r, t, ...) ⊢ x ↓ k\*<x\*> → v\*<x\*>,

¬∃ k\*<y\*> = k\*<x\*>,

(s, ...) ⊢ \fBThis\fR ↓ u
.SEME
Construct a new literal frame.

.TP
Create a new template
.SEM Γ ⊢ \fBTemplate {\fR a:(A / G / X)* \fB}\fR ↓ < Γ; k\*<x\*> → e\*<x\*> >

∀ x ∈ a : Γ ⊢ x ↓ k\*<x\*> → e\*<x\*>,

¬∃ k\*<y\*> = k\*<x\*>
.SEME

Create a new template, not based on any current template.

.TP
Extend a template
.SEM (t, ...) ⊢ \fBTemplate\fR source:E\*<+\*> \fB{\fR a:(A / G / O / X)* \fB}\fR ↓ < (t, ..., s, ...); ∀ m : k\*<m\*> → e\*<m\*> >

(t, ...) ⊢ source ↓ S = < (s, ...); k\*<s\*> → e\*<s\*>, ... >,

∀ x ∈ a, (∃ k\*<s\*> : k\*<x\*> = k\*<s\*>) : (t, ...); e\*<s\*> ⊢ x ↓ k\*<m\*> → e\*<m\*>,

∀ x ∈ a, (¬∃ k\*<s\*> : k\*<x\*> = k\*<s\*>) : (t, ...) ⊢ x ↓ k\*<m\*> → e\*<m\*>,

∀ k\*<s\*> → e\*<s\*> : ¬∃ k\*<s\*> : k\*<x\*> = k\*<s\*> : k\*<m\*> → e\*<m\*> = k\*<s\*> → e\*<s\*>
.SEME

Create a template that inherits from an existing template. It contains all the attributes of the existing template unless amended by the specified attributes. The specified attributes can add, replace, amend, or remove attributes from the existing template. Any unmentioned attributes are inherited directly. The new template has the lookup context of the context where the modification was performed followed by the context of the existing template.

.TP
Create a new function-like template
.SEM Γ ⊢ \fBFunction (\fR( a:(A / F / G) (\fB,\fR a:(A / F / G))*)? \fB)\fR body:E\*<0\*> ↓ < Γ; k\*<x\*> → e\*<x\*> \fBvalue\fR → body >

∀ x ∈ a : Γ ⊢ x ↓ k\*<x\*> → e\*<x\*>,

¬∃ k\*<y\*> = k\*<x\*>

¬∃ k\*<y\*> = \fBvalue\fR
.SEME

Create a new template, not based on any current template.

.TP
Nullable lookup
.SEM Γ ⊢ expr:E\*<+\*> \fB?\fR names:(\fB.\fR I)+ ↓ v
Γ ⊢ \fBIf\fR expr \fBIs Null Then Else Null\fR (\fRexpr\fB)\fRnames ↓ v
.SEME

.TP
Bit-wise negation
.SEM Γ ⊢ \fB-\fR expr:E\*<+\*> ↓ BITWISE_COMP(v) :: Int
Γ ⊢ expr ↓ v :: Int
.SEME

.TP
Logical negation
.SEM Γ ⊢ \fB!\fR expr:E\*<+\*> ↓ False
Γ ⊢ expr ↓ True
.SEME

.SEM Γ ⊢ \fB!\fR expr:E\*<+\*> ↓ True
Γ ⊢ expr ↓ False
.SEME

.TP
Numeric negation
.SEM Γ ⊢ \fB-\fR expr:E\*<+\*> ↓ -v :: Int
Γ ⊢ expr ↓ v :: Int
.SEME

.SEM Γ ⊢ \fB-\fR expr:E\*<+\*> ↓ -v :: Float
Γ ⊢ expr ↓ v :: Float
.SEME

.TP
Unique identifier generation
.SEM Γ ⊢ \fBGenerateId\fR expr:E\*<+\*> ↓ i :: Str
Γ ⊢ expr ↓ < i; Δ; ... >
.SEME

Extracts the unique identifier from a frame. The implementation makes no guarantees about the format of these identifiers.

This expression is meant to have a similar function to LISP's \fIgensym\fR or XPath's \fIgenerate-id\fR. It is intended to allow generating unique, though unhelpfully opaque, identifiers in generated code. For instance, to generate temporary variable names when generating the compiler. The \fBId\fR function is similar Clojure's auto-\fIgensym\fR syntax; with the scope of a frame, the same identifier is available.

.SS EXPRESSION SYNTAX (E) – FUNCTION-LIKE TEMPLATE INSTANTIATION

.TP
Call template with arguments
.SEM Γ ⊢ fn:E\*<+\*> \fB( )\fR ↓ t
Γ ⊢ \fB(\fR fn \fB{ args : [] }).value\fR ↓ t
.SEME

.SEM Γ ⊢ fn:E\*<+\*> \fB(\fRarg:E\*<+\*> (\fB,\fR arg:E\*<+\*>)*(\fB,\fR name:I \fB:\fR nameexpr:E\*<0\*>  )*\fB)\fR ↓ t
∀ arg : Γ ⊢ arg ↓ v\*<arg\*>,

∀ nameexpr : Γ ⊢ nameexpr ↓ v\*<nameexpr\*>,

Γ ⊢ \fB(\fR fn \fB{ args : [\fR v\*<arg\*>, ... \fB ] \fR name \fB:\fR v\*<nameexpr\*>, ... \fB}).value\fR ↓ t
.SEME

.SEM Γ ⊢ fn:E\*<+\*> \fB(name:I \fB:\fR nameexpr:E\*<0\*> (\fB,\fR name:I \fB:\fR nameexpr:E\*<0\*> )*\fB)\fR

∀ nameexpr : Γ ⊢ nameexpr ↓ v\*<nameexpr\*>,

Γ ⊢ \fB(\fR fn \fB{ args : [] \fR name \fB:\fR v\*<nameexpr\*>, ... \fB}).value\fR ↓ t
.SEME

Unlike normal template evaluation, all expressions are captured in the current context, instead of the context of the instantiation.

.SS EXPRESSION SYNTAX (E) – LOOKUP
.TP
Access external data

.HP
.B Definition:
\fBFrom\fR ([\fBA\fR-\fBZa\fR-\fBz0\fR-\fB9.+-\fR]+\fB:\fR[\fBA\fR-\fBZa\fR-\fBz0\fR-\fB9~!*'();@&=+$,/?%#[].+:-\fR]+)

This expression returns data external to the program, described by the URI provided. This expression access as library access, input of user data, and a foreign data interface. The exact semantics of the command are implementation-defined, however, the same URI must yield the same data during the execution of the program and the current context must be irrelevant to the import mechanism (i.e., the return value must not depend lookup expressions, however, it can return a template which does).

Evaluate an expression, which must be a frame, then begin lookup of the names provided from that context.

The interpreter may process all \fBFrom\fR expressions first, outside of normal program flow. That is, \fBFalse && From foo:\fR may evaluate the \fBFrom\fR expression.

.TP
Contextual lookup
.SEM Γ ⊢ names:N names:(\fB.\fR N)* ↓ v
Γ ⊢ CONTEXTUAL(names) ↓ v
.SEME

This does a dynamically-scoped lookup. It searches all the existing frame contexts for a matching name. If the value in any frame is not a frame, this is not an error. Any frame that does not match the complete path of names is simply ignored. It is an error if there are no more contexts in which to search and there are still unsatisfied names.

It is not an error if any value is not defined so long as it is not the first item in an Γ\*<n\*>. See EVALUATION SEMANTICS for more details.

.TP
Perform direct lookup
.SEM Γ ⊢ expr:E\*<+\*> \fB.\fR names:I names:(\fB.\fR I)* ↓ u
Γ ⊢ expr ↓ f :: Frame,

(f) ⊢ CONTEXTUAL(names) ↓ u
.SEME
Get values from inside of a frame. Do not perform contextual lookup.

.SS EXPRESSION SYNTAX (E) – TERMINAL
.TP
Subexpression
.SEM Γ ⊢ \fB(\fR expr:E\*<0\*> \fB)\fR ↓ v
Γ ⊢ expr ↓ v
.SEME

.TP
Literal list
.SEM (s, ...) ⊢ \fB[\fR (arg:E\*<0\*> (\fB,\fR arg:E\*<0\*>)*)? \fB]\fR ↓ t = < u; (t, s, ...); ∀ x ∈ arg : (x + 1) → v\*<x\*> >
∀ x ∈ arg : (s, ...) ⊢ x ↓ v\*<x\*>,

(s, ...) ⊢ \fBThis\fR ↓ u
.SEME

This creates a list-like frame. Indexing is 1-based.

.TP
Identifier-like string
.SEM \fB$\fR name:I ↓ \(dqname\(dq :: String
.SEME

Produce a string that is parsed as an identifier.

.TP
Get contextual lookup handler
.SEM (a, ...) ⊢ \fBContextual\fR ↓ CONTEXTUAL :: LookupHandler
.SEME

Return the lookup handler that implements contextual lookup as defined in CONTEXTUAL LOOKUP HANDLER.

.TP
Access containing frame
.SEM (a, ...) ⊢ \fBContainer\fR ↓ v
(...) ⊢ \fBThis\fR ↓ v
.SEME

.SEM (a*, ...) ⊢ \fBContainer\fR ↓ v
(...) ⊢ \fBContainer\fR ↓ v
.SEME

Return the frame containing current frame. This is the second frame in the environment not marked with a *.

.TP
Boolean false literal
.SEM \fBFalse\fR ↓ False :: Bool
.SEME

The Boolean falsehood value. Alternatively, thought of as boolshit.

.TP
Largest floating literal
.SEM \fBFloatMax\fR ↓ x :: Float
.SEME

The value of \fIx\fR is the implementation-defined largest value representable as a floating point number.

.TP
Smallest floating literal
.SEM \fBFloatMin\fR ↓ x :: Float
.SEME

The value of \fIx\fR is the implementation-defined smallest value representable as a floating point number.

.TP
Create unique identifier for the current frame
.SEM Γ ⊢ \fBId\fR ↓ v
Γ ⊢ \fBGenerateId This\fR ↓ v
.SEME

This is syntactic sugar for generating an identifier for the current frame. See \fBGenerateId\fR for details.

.TP
Infinity literal
.SEM \fBInfinity\fR ↓ ∞ :: Float
.SEME

A floating point value representing positive infinity.

.TP
Largest integer literal
.SEM \fBIntMax\fR ↓ x :: Int
.SEME

The value of \fIx\fR is the implementation-defined largest value representable as an integer. It should be strictly greater than zero.

.TP
Smallest integer literal
.SEM \fBIntMin\fR ↓ x :: Int
.SEME

The value of \fIx\fR is the implementation-defined smallest value representable as an integer. It should be strictly smaller than zero.

.TP
Not-a-number literal
.SEM \fBNaN\fR ↓ NaN :: Float
.SEME

This is the IEEE not-a-number value.

.TP
Null literal
.SEM \fBNull\fR ↓ ∅
.SEME

.TP
Access current frame
.SEM (a, ...) ⊢ \fBThis\fR ↓ a
.SEME

.SEM (a*, ...) ⊢ \fBThis\fR ↓ v
(...) ⊢ \fBThis\fR ↓ v
.SEME

Return the current frame. This is the first frame in the environment not marked with a *.

.TP
Boolean true literal
.SEM \fBTrue\fR ↓ True :: Bool
.SEME

The Boolean truthiness value.

.TP
Floating point literal
.SEM (\fB0\fR/[\fB1\fR-\fB9\fR][\fB0\fR-\fB9\fR]*)\fB.\fR[\fB0\fR-\fB9\fR]*((\fBe\fR/\fBE\fR)(\fB0\fR/(\fB-\fR)?[\fB1\fR-\fB9\fR][\fB0\fR-\fB9\fR]*)? ↓ v :: Float
.SEME

IEEE 754 floating point number.

.TP
Integer literal
.SEM \fB0\fR/[\fB1\fR-\fB9\fR][\fB0\fR-\fB9\fR]*/\fB0x\fR?[\fB0\fR-\fB9\fR\fBA\fR-\fBF\fR\fBa\fR-\fBf\fR]+ ↓ v :: Int
.SEME

Decimal or hexadecimal integers.

.TP
Integer literal with units
.SEM t:T\*<0\*> ↓ v :: Int
.SEME
.SEM (\fB0\fR/[\fB1\fR-\fB9\fR][\fB0\fR-\fB9\fR]*)\fBk\fR ↓ v * 1000 :: Int
.SEME
.SEM (\fB0\fR/[\fB1\fR-\fB9\fR][\fB0\fR-\fB9\fR]*)\fBM\fR ↓ v * 1000² :: Int
.SEME
.SEM (\fB0\fR/[\fB1\fR-\fB9\fR][\fB0\fR-\fB9\fR]*)\fBG\fR ↓ v * 1000³ :: Int
.SEME

.SEM (\fB0\fR/[\fB1\fR-\fB9\fR][\fB0\fR-\fB9\fR]*)\fBki\fR ↓ v * 1024 :: Int
.SEME
.SEM (\fB0\fR/[\fB1\fR-\fB9\fR][\fB0\fR-\fB9\fR]*)\fBMi\fR ↓ v * 1024² :: Int
.SEME
.SEM (\fB0\fR/[\fB1\fR-\fB9\fR][\fB0\fR-\fB9\fR]*)\fBGi\fR ↓ v * 1024³ :: Int
.SEME

Integers with units.

.TP
String expression

.SEM Γ ⊢ \fB\(dq\fRa:S*\fB\(dq\fR ↓ \(dqv\*<0\*>v\*<1\*>...v\*<n\*>\(dq :: Str
Γ ⊢ a\*<n\*> ↓ v\*<n\*>
.SEME

.SS STRING PARTS (S)

UNICODE converts a number to its Unicode code-point.

.TP
Characters other than quote or backslash
.SEM x:[^\fB\(dq\\\\\fR]+ ↓ x
.SEME

.TP
Audible bell
.SEM \fB\\\\a\fR ↓ UNICODE(7)
.SEME

.TP
Backspace
.SEM \fB\\\\b\fR ↓ UNICODE(8)
.SEME

.TP
Form feed
.SEM \fB\\\\f\fR ↓ UNICODE(12)
.SEME

.TP
New line
.SEM \fB\\\\n\fR ↓ UNICODE(10)
.SEME

.TP
Carriage return
.SEM \fB\\\\r\fR ↓ UNICODE(13)
.SEME

.TP
Horizontal tab
.SEM \fB\\\\t\fR ↓ UNICODE(9)
.SEME

.TP
Vertical tab
.SEM \fB\\\\v\fR ↓ UNICODE(11)
.SEME

.TP
Quotation mark
.SEM \fB\\\\\(dq\fR ↓ UNICODE(34)
.SEME

.TP
Octal escape
.SEM \fB\\\\\fRa:[\fB0\fR-\fB7\fR]b:[\fB0\fR-\fB7\fR]c:[\fB0\fR-\fB7\fR] ↓ UNICODE(a * 64 + b * 8 + c)
.SEME

.TP
ASCII hex escape
.SEM \fB\\\\x\fRa:[\fB0\fR-\fB9a\fR-\fBfA\fR-\fBF\fR]b:[\fB0\fR-\fB9a\fR-\fBfA-\fBF\fR] ↓ UNICODE(a * 16 + b)
.SEME

.TP
Unicode hex escape
.SEM \fB\\\\u\fRa:[\fB0\fR-\fB9a\fR-\fBfA\fR-\fBF\fR]b:[\fB0\fR-\fB9a\fR-\fBfA\fR-\fBF\fR]c:[\fB0\fR-\fB9a\fR-\fBfA\fR-\fBF\fR]d:[\fB0\fR-\fB9a\fR-\fBfA\fR-\fBF\fR] ↓ UNICODE(a * 4096 + b * 256 + c * 16 + d)
.SEME

.TP
Astral plane Unicode hex escape
.SEM \fB\\\\U\fRa:[\fB0\fR-\fB9a\fR-\fBfA\fR-\fBF\fR]b:[\fB0\fR-\fB9a\fR-\fBfA\fR-\fBF\fR]c:[\fB0\fR-\fB9a\fR-\fBfA\fR-\fBF\fR]d:[\fB0\fR-\fB9a\fR-\fBfA\fR-\fBF\fR]e:[\fB0\fR-\fB9a\fR-\fBfA\fR-\fBF\fR]f:[\fB0\fR-\fB9a\fR-\fBfA\fR-\fBF\fR]g:[\fB0\fR-\fB9a\fR-\fBfA\fR-\fBF\fR]h:[\fB0\fR-\fB9a\fR-\fBfA\fR-\fBF\fR] ↓ UNICODE(a * 268435456 + b * 16777216 + c * 1048576 + d * 65536 + e * 4096 + f * 256 + g * 16 + h)
.SEME

.TP
Embedded expression
.SEM Γ ⊢ \fB\\\\(\fR expr:E\*<0\*> \fB)\fR ↓ v
Γ ⊢ expr \fBTo Str\fR ↓ v
.SEME

.SH OTHER SYNTAX
.SH IDENTIFIERS (I)
.SEM [\fBa\fR-\fBz\fR][\fBa\fR-\fBzA\fR-\fBZ0\fR-\fB9_\fR]*
.SEME

.SH FRAME PARTS
.TP
Frame attribute definition (A)
.SEM Γ ⊢ name:DI \fB:\fR expr:E ↓ n → expr
Γ ⊢ name ↓ n
.SEME
.SEM Γ; R ⊢ name:DI \fB:\fR expr:E ↓ n → expr
Γ ⊢ name ↓ n
.SEME
Define a new attribute in a frame, equal to some expression.

.TP
In a template, define an attribute that must be overridden. (X)
.SEM Γ ⊢ name:DI \fB: Required\fR ↓ n → \fBError \(dqAttribute \fRn\fB must be overridden.\(dq\fR
Γ ⊢ name ↓ n
.SEME
.SEM Γ; R ⊢ name:DI \fB: Required\fR ↓ n → \fBError \(dqAttribute \fRn\fB must be overridden.\(dq\fR
Γ ⊢ name ↓ n
.SEME

Create an attribute whose value is an error requiring an override.

.TP
In a function-like template, define an attribute that must be overridden. (F)
.SEM Γ ⊢ name:I ↓ name → \fBError \(dqAttribute \fRname\fB must be overridden.\(dq\fR
.SEME

Create an attribute whose value is an error requiring an override.

.TP
In a template, define an attribute that is expected to be found via lookup. (X)
.SEM Γ ⊢ name:I \fB: Used\fR ↓
.SEME
.SEM Γ; R ⊢ name:I \fB: Used\fR ↓ name → R
.SEME

This does not do anything. It is intended to convey that an attribute should be available for inside out lookup. This is inteded as a place to collect documentation.

.TP
Override sub-template definition. (O)
.SEM Γ; R ⊢ name:DI \fB+:\fR \fB{\fR a:(A / O / X)+ \fB}\fR ↓ name → \fBTemplate \fR R \fB{\fR a \fB}\fR
Γ ⊢ name ↓ n
.SEME

The name \fIoriginal\fR must be selected to be entirely unique in the program scope.

.TP
Redefine an attribute. (O)
.SEM Γ; R ⊢ name:DI \fB+\fR original:I \fB:\fR expr:E ↓ name → \fBLet\fR original \fB:\fR R \fBIn\fR expr
Γ ⊢ name ↓ n
.SEME

.TP
Remove definition for an attribute. (O)
.SEM Γ; R ⊢ name:I \fB: Drop\fR ↓
.SEME

The name must be present in the existing frame or an error occurs.

.TP
Define an attribute that is eagerly evaluated instead of lazily evaluated. (G)
.SEM Γ ⊢ name:DI \fB: Now\fR expr:E ↓ n → C
Γ ⊢ name ↓ n

Γ ⊢ expr ↓ v,

∀ Δ : Δ ⊢ C ↓ v
.SEME
.SEM Γ; R ⊢ name:DI \fB: Now\fR expr:E ↓ n → C
Γ ⊢ name ↓ n

Γ ⊢ expr ↓ v,

∀ Δ : Δ ⊢ C ↓ v
.SEME

.SH ATTRIBUTE DEFINITION NAMES (DI)
Fixed identifier
.SEM Γ ⊢ name:I ↓ n
.SEME

.SEM Γ ⊢ \fBAttribute(\fR name:E\*<0\*> \fB)\fR ↓ n
Γ ⊢ name ↓ n :: Str,

IDENTIFIER(n)
.SEME

.SEM Γ ⊢ \fBAttribute(\fR name:E\*<0\*> \fB)\fR ↓ v
Γ ⊢ name ↓ v :: Int
.SEME

.TP
Type-directed name
.SEM Γ ⊢ \fBTypeOf(\fR expr:E\*<0\*> \fB)\fR ↓ bin
Γ ⊢ expr ↓ v :: Bin
.SEME

.SEM Γ ⊢ \fBTypeOf(\fR expr:E\*<0\*> \fB)\fR ↓ bool
Γ ⊢ expr ↓ v :: Bool
.SEME

.SEM Γ ⊢ \fBTypeOf(\fR expr:E\*<0\*> \fB)\fR ↓ float
Γ ⊢ expr ↓ v :: Float
.SEME

.SEM Γ ⊢ \fBTypeOf(\fR expr:E\*<0\*> \fB)\fR ↓ frame
Γ ⊢ expr ↓ v :: Frame
.SEME

.SEM Γ ⊢ \fBTypeOf(\fR expr:E\*<0\*> \fB)\fR ↓ int
Γ ⊢ expr ↓ v :: Int
.SEME

.SEM Γ ⊢ \fBTypeOf(\fR expr:E\*<0\*> \fB)\fR ↓ lookup_handler
Γ ⊢ expr ↓ v :: LookupHandler
.SEME

.SEM Γ ⊢ \fBTypeOf(\fR expr:E\*<0\*> \fB)\fR ↓ null
Γ ⊢ expr ↓ v :: Unit
.SEME

.SEM Γ ⊢ \fBTypeOf(\fR expr:E\*<0\*> \fB)\fR ↓ str
Γ ⊢ expr ↓ v :: Str
.SEME

.SEM Γ ⊢ \fBTypeOf(\fR expr:E\*<0\*>) ↓ template
Γ ⊢ expr ↓ v :: Template
.SEME

.SH TYPE DEFINITIONS (T)
.SEM \fBBin\fR ↓ Bin
.SEME
.SEM \fBBool\fR ↓ Bool
.SEME
.SEM \fBFloat\fR ↓ Float
.SEME
.SEM \fBInt\fR ↓ Int
.SEME
.SEM \fBStr\fR ↓ Str
.SEME
.SEM \fBTemplate\fR ↓ Template
.SEME
.SEM \fBFrame\fR ↓ Frame
.SEME


.SH FRICASSÉE SOURCE (FS)

.TP
Zipped attribute selector [G]
.SEM (t, ...) ⊢ value\*<1\*>:I \fB:\fR input\*<1\*>:(\fBName\fR / \fBOrdinal\fR / E\*<0\*>) (\fB,\fR value\*<2\*>:I \fB:\fR input\*<2\*>:(\fBName\fR / \fBOrdinal\fR / E\*<0\*>))* ↓ W
∀ i ∈ input:E : (t, ...) ⊢ i ↓ < u\*<i\*>; Δ\*<i\*>; kk\*<ij\*> → vv\*<ij\*> >,

V(j) = ∀ i ∈ input:value\*<i\*> → vv\*<ij\*>

A(j) = ∀ i ∈ input:\fBName\fR : value\*<i\*> → j,

K = ∀ i ∈ input:E : ∪ k\*<ij\*>,

O(j) = ∀ i ∈ input:\fBOrdinal\fR : value\*<i\*> → |{ k ∈ K : k\*<j\*> < j }| :: Int

W = { ∀ j : ( < u; (w\*<j\*>, t, ...); V(j) ∪ A(j) ∪ O(j) >, t, ...) }
.SEME

Produce a list of witnesses where each \fIvalue\fR identifier matches the value of the current attribute in each of the frame inputs, or null, if not in the matching frame. The special input \fBName\fR is the name of the current attribute and the special input \fBOrdinal\fR is the position of the current attribute.

.TP
Pass-through selector [G]
.SEM (t, ...) ⊢ \fBEach\fR input:E\*<0\*> ↓ { ∀ i :  (v\*<i\*>, t, ...) }
(t, ...) ⊢ input ↓ < u\*<i\*>; Δ\*<i\*>; k\*<i\*> → v\*<i\*> :: Frame >
.SEME

Passes-though a list of witnesses provided as a frame of frames.

.TP
Trasnformed source
.SEM Γ ⊢ base:FS transform:FT ↓ X
Γ ⊢ base ↓ W,

Γ; W ⊢ transform ↓ X
.SEME

.SH FRICASSÉE TRANSFORM (FT)

.TP
Intermediate accumulator [G]
.SEM Γ; W ⊢ \fBAccumulate\fR expr:E\*<0\*> \fBWith\fR name:I \fB:\fR initial:E\*<0\*> ↓ (Δ\*<1\*>, Δ\*<2\*>, ... )

Γ ⊢ initial ↓ v\*<0\*>,

∀ i : Δ\*<i\*> = (<u\*<i\*>; w\*<i\*>; name → v\*<i - 1\*> >) +  w\*<i\*>,

∀ i : Δ\*<i\*> ⊢ expr ↓ v\*<i\*>
.SEME

Bind a new value in each frame that is carried across all frames in the iteration order.

.TP
Start range limiting [G]
.SEM Γ; (Δ\*<0\*>, ..., Δ\*<n\*>) ⊢ \fBDrop\fR expr:E\*<0\*> ↓  X


∀ Γ ⊢ expr ↓ k :: Int,

X = () | k ≥ n,

X = (Δ\*k\*>, Δ\*<k+1\*>, ..., Δ\*<n\*>) | k < n
.SEME

.TP
End range limiting [G]
.SEM Γ; (Δ\*<0\*>, ..., Δ\*<n\*>) ⊢ \fBDropLast\fR expr:E\*<0\*> ↓ X

∀ Γ ⊢ expr ↓ k :: Int,

X = (Δ\*0\*>, Δ\*<1\*>, ..., Δ\*<k\*>) | k < n

X = () | k ≥ n
.SEME

.TP
Start condtional input limiting [G]
.SEM Γ; W ⊢ \fBDropWhile\fR expr:E\*<0\*> ↓ X
∀ w\*<i\*> ∈ W : w\*<i\*> ⊢ expr ↓ v\*<i\*> :: Bool,

X = { w\*<i\*> ∈ W | ∃ j ≤ i : v\*<j\*> = False }
.SEME

Drop input while condition is met.

.TP
Additional binding [=]
.SEM Γ; W ⊢ \fBLet\fR name\*<0\*>:I \fB:\fR nameexpr:E\*<0\*> (\fB,\fR name\*<1\*>:I \fB:\fR nameexpr:E\*<1\*> )* ↓ (∀ i : Δ\*<i\*>)

∀ w\*<i\*> ∈ W, k : w\*<i\*> ⊢ nameexpr\*<k\*>n ↓ v\*<ik\*>,

∀ w\*<i\*> ∈ W : Δ\*<i\*> = < u\*<i\*>; Δ\*<i\*>; ∀ k : name\*<k\*> → v\*<ik\*> >
.SEME

Modify a list of witnesses, provided as a frame of frames, to include new entires or replace existing ones.

.TP
Flatten frames [G] TODO
.SEM Γ; W ⊢ \fBFlatten\fR name\*<0\*>:I \fB:\fR expr:(\fBName\fR / \fBOrdinal\fR / E\*<0\*>) (\fB,\fR name\*<1\*>:I \fB:\fR expr:(\fBName\fR / \fBOrdinal\fR / E\*<0\*>) )* ↓ Δ\*<1\*> +  Δ\*<2\*> + ...

∀ w\*<i\*> ∈ W :  w\*<i\*> name\*<0\*>:I \fB:\fR expr:E\*<0\*> (\fB,\fR name\*<1\*>:I \fB:\fR expr:E\*<1\*> )* ↓ Δ\*<i\*>
.SEME

Expand nested frames in a stream. This uses the same semantics as the merge attribute selector.

.TP
Group by values [G]
.SEM Γ; W ⊢ \fBGroup\fR collected_name\*<0\*>:I \fB:\fR collector:FK (\fB,\fR collected_name\*<1\*>:I \fB:\fR collector:FK )* \fBBy\fR discriminator_name\*<0\*>:I \fB:\fR discriminator_expr:E\*<0\*> (\fB,\fR discriminator_name\*<1\*>:I \fB:\fR discriminator_expr:E\*<1\*> )* ↓ Δ\*<1\*> +  Δ\*<2\*> + ...

∀ w\*<i\*> ∈ W, discriminator_expr\*<k\*> ∈ discriminator_expr : w\*<i\*> ⊢ discriminator_expr\*<k\*> ↓ d\*<ik\*> :: t\*<ik\*>,

∀ k : t\*<1k\*> = t\*<2k\*> = ...,

f(x) = i : ∀ k, p < i : d\*<ik\*> ≠ d\*<pk\*>,

∀ x, collector\*<j\*> ∈ collector : Γ; (∀ w\*<i\*> ∈ W : ∀ z, k : d\*<zk\*> = d\*f(x)k\*> ) ⊢ collector\*<j\*> ↓ c\*<xj\*>,

Δ\*<x\*> = < u\*<x\*>; Γ; (∀ k : discriminator_name\*<k\*> → d\*<f(x)k\*>), (∀ j, k : collected_name\*<j\*> →  c\*<xj\*>) >

.SEME

.TP
Group by chunk [G]
.SEM Γ; S ⊢ \fBGroup\fR collected_name\*<0\*>:I \fB:\fR collector:FK (\fB,\fR collected_name\*<1\*>:I \fB:\fR collector:FK )* \fBBy\fR width:E\*<+\*> )* ↓ Δ\*<1\*> +  Δ\*<2\*> + ...


Γ ⊢ width ↓ w :: Int,

∀ 0 ≤ x < ⌈|S| / w⌉, collector\*<j\*> ∈ collector : Γ; (∀ s\*<i\*> ∈ S : x × w ≤ x < (x + 1) × w) ⊢ collector\*<j\*> ↓ c\*<xj\*>,

Δ\*<x\*> = < u\*<x\*>; Γ; (∀ j, k : collected_name\*<j\*> →  c\*<xj\*>) >

.SEME

.TP
Group by stripe [G]
.SEM Γ; S ⊢ \fBGroup\fR collected_name\*<0\*>:I \fB:\fR collector:FK (\fB,\fR collected_name\*<1\*>:I \fB:\fR collector:FK )* \fBBy\fR width:E\*<+\*> )* ↓ Δ\*<1\*> +  Δ\*<2\*> + ...


Γ ⊢ width ↓ w :: Int,

∀ 0 ≤ x < w, collector\*<j\*> ∈ collector : Γ; (∀ s\*<i\*> ∈ S : i ≡ x (mod w)) ⊢ collector\*<j\*> ↓ c\*<xj\*>,

Δ\*<x\*> = < u\*<x\*>; Γ; (∀ j, k : collected_name\*<j\*> →  c\*<xj\*>) >

.SEME

.TP
Value ordered [U]
.SEM Γ; (Δ\*<0\*>, ..., Δ\*<n\*>) ⊢ \fBOrder\fR \fBBy\fR expr:E\*<0\*> ↓ (Δ\*<f(0)\*>, Δ\*<f(1)\*>, ..., Δ\*<f(n)\*>)

∀ Δ\*<i\*> : Δ\*<i\*>* ⊢ expr ↓ v\*<i\*> :: t\*<i\*>,

t\*<0\*> = t\*<1\*> = ... = t\*<n\*>,

f(\*<i\*>) ≥ j : (v\*<j\*> ⇔ v\*<f(i - 1)\*>) ≥ 0,

f(\*<i\*>) ≤ j : (v\*<j\*> ⇔ v\*<f(i - 1)\*>) ≤ 0
.SEME

Order the values based on an expression. The ordering implied by ⇔ is the same as in the \fB<=>\fR expression. For this to be possible, the types of the returned expression must be the same and comparable. If two items have the same value, the order is implementation-defined.

.TP
Reverse ordered [U]
.SEM Γ; (Δ\*<0\*>, ..., Δ\*<n\*>) ⊢ \fBReverse\fR ↓ (Δ\*<n\*>, ..., Δ\*<0\*>)
.SEME

Reverses the order of the witnesses.

.TP
Randomly shuffle the order [U]
.SEM Γ; W ⊢ \fBShuffle\fR ↓ SHUF(W)
.SEME

Where \fISHUF\fR produces a random permutation of its argument.

.TP
Start range limiting [G]
.SEM Γ; (Δ\*<0\*>, ..., Δ\*<n\*>) ⊢ \fBTake\fR expr:E\*<0\*> ↓ (Δ\*0\*>, Δ\*<1\*>, ..., Δ\*<z\*>)

∀ Γ ⊢ expr ↓ k :: Int,

z = MIN(k, n)
.SEME

.TP
End range limiting [G]
.SEM Γ; (Δ\*<0\*>, ..., Δ\*<n\*>) ⊢ \fBTakeLast\fR expr:E\*<0\*> ↓ (Δ\*z\*>, Δ\*<z+1\*>, ..., Δ\*<n\*>)

∀ Γ ⊢ expr ↓ k :: Int,

z = MAX(n - k, 0)
.SEME

.TP
Start condtional input limiting [G]
.SEM Γ; W ⊢ \fBTakeWhile\fR expr:E\*<0\*> ↓ X
∀ w\*<i\*> ∈ W : w\*<i\*> ⊢ expr ↓ v\*<i\*> :: Bool,

X = { w\*<i\*> ∈ W | ∀ j ≤ i : v\*<j\*> = True }
.SEME

Keep input while condition is met.

.TP
Filtering [=]
.SEM Γ; W ⊢ \fBWhere\fR expr:E\*<0\*> ↓ X
∀ w\*<i\*> ∈ W : w\*<i\*> ⊢ expr ↓ v\*<i\*> :: Bool,

X = { w\*<i\*> ∈ W | v\*<i\*> = True }
.SEME

.SH FRICASSÉE RESULTS (FR)

.TP
Reducer (fold) [S]
.SEM Γ; ( ) ⊢ \fBReduce\fR expr:E\*<0\*> \fBWith\fR name:I \fB:\fR initial:E\*<+\*> ↓ v

Γ ⊢ initial ↓ v
.SEME
.SEM Γ; (Δ\*<1\*>, Δ\*<2\*>, ..., Δ\*<n\*>) ⊢ \fBReduce\fR expr:E\*<0\*> \fBWith\fR name:I \fB:\fR initial:E\*<+\*> ↓ v\*<n\*>
Γ ⊢ initial ↓ v\*<0\*>,

∀ i : (< u\*<i\*>; Δ\*<i\*>; name → v\*<i - 1\*> >) + Δ\*<i\*> ⊢ expr ↓ v\*<i\*>
.SEME

This reduces an expression to a single value.

.TP
String concatentation [S]
.SEM Γ; ( ) ⊢ \fBConcat\fR expr:E\*<0\*> \fBWith\fR delimiter:E\*<+\*> ↓  ∅
.SEME
.SEM Γ; (Δ\*<1\*>, Δ\*<2\*>, ..., Δ\*<n\*>) ⊢ \fBConcat\fR expr:E\*<0\*> \fBWith\fR delimiter:E\*<+\*> ↓ \(dqv\*<0\*>dv\*<1\*>d...dv\*<n\*>\(dq
Γ ⊢ delimiter \fBTo Str\fR ↓ d,

∀ Δ\*<i\*>: ⊢ expr \fBTo Str\fR ↓ v\*<i\*>
.SEME

This concatenates all items, as strings, with a delimiter.

.TP
Anonymous cumulative reduce (scan) [S]
.SEM Γ; ( ) ⊢ \fBScan\fR expr:E\*<0\*> \fBWith\fR name:I \fB:\fR initial:E\*<+\*> ↓  <u; Γ; >

Γ ⊢ initial ↓ v
.SEME
.SEM Γ; ( Δ\*<1\*>, Δ\*<2\*>, ..., Δ\*<n\*>) ⊢ \fBScan\fR expr:E\*<0\*> \fBWith\fR name:I \fB:\fR initial:E\*<+\*> ↓  <u; Γ; ∀ x > 0 : x → v\*<x\*> >
Γ ⊢ initial ↓ v\*<0\*>,

∀ i : (< u\*<i\*>; Δ\*<i\*>; name → v\*<i - 1\*> >) + Δ\*<i\*> ⊢ expr ↓ v\*<i\*>
.SEME

This reduces an expression to an accumulating list.

.TP
Named cumulative reduce (scan) [S]
.SEM Γ; ( ) ⊢ \fBScan\fR attr:E\*<0\*> \fB:\fR expr:E\*<0\*> \fBWith\fR name:I \fB:\fR initial:E\*<+\*> ↓  <u; Γ; >

Γ ⊢ initial ↓ v
.SEME
.SEM Γ; ( Δ\*<1\*>, Δ\*<2\*>, ..., Δ\*<n\*>) ⊢ \fBScan\fR attr:E\*<0\*> \fB:\fR expr:E\*<0\*> \fBWith\fR name:I \fB:\fR initial:E\*<+\*> ↓  <u; Γ; ∀ x > 0 : n\*<x\*> → v\*<x\*> >
Γ ⊢ initial ↓ v\*<0\*>,

∀ i : (< u\*<i\*>; Δ\*<i\*>; name → v\*<i - 1\*> >) + Δ\*<i\*> ⊢ expr ↓ v\*<i\*>

∀ i : (< u\*<i\*>; Δ\*<i\*>; name → v\*<i - 1\*> >) + Δ\*<i\*> ⊢ attr ↓ n\*<i\*>
.SEME

This reduces an expression to an accumulating list.

.TP
Count matches [I]
.SEM Γ; ( Δ\*<1\*>, Δ\*<2\*>, ..., Δ\*<n\*>) ⊢ \fBCount\fR ↓ n :: Int
.SEME

Count the number of items in a stream.

.TP
Single value selector [I]
.SEM Γ; (Δ) ⊢ \fBSingle\fR expr:E\*<+\*> ↓ v

Δ ⊢ expr ↓ v
.SEME

Select a single item from a stream. If multiple values are present, an error occurs. If no value is present, an error occurs.

.TP
Single value selector with default [I]
.SEM Γ; (Δ) ⊢ \fBSingle\fR expr:E\*<+\*> \fBOr\fR default:E\*<+\*> ↓ v

Δ ⊢ expr ↓ v
.SEME

.SEM Γ; () ⊢ \fBSingle\fR expr:E\*<+\*> \fBOr\fR default:E\*<+\*> ↓ v

Γ ⊢ default ↓ v
.SEME

Select a single item from a stream. If multiple values are present, an error occurs.

.TP
Anonymous value generator [S]
.SEM Γ; ( Δ\*<0\*>, Δ\*<1\*>, ... ) ⊢ \fBSelect\fR expr:E\*<+\*> ↓ r = < u; Γ; ∀ x : x → v\*<x\*> >

∀ Δ\*<x\*> : Δ\*<x\*> ⊢ expr ↓ v\*<x\*>
.SEME

This produces a list-like frame by evaluating the supplied expression on each frame of witnesses.

.TP
Named attribute frame generator [I]
.SEM Γ; ( Δ\*<0\*>, Δ\*<1\*>, ... ) ⊢ \fBSelect\fR attr:E\*<0\*> \fB:\fR expr:E\*<+\*> ↓ r = < u; Γ; k\*<x\*> → v\*<x\*> >

Δ\*<x\*>* ⊢ attr ↓ k\*<x\*> :: Str ∨ Δ\*<x\*> ⊢ attr ↓ v :: Int ∧ k\*<x\*> = v,

Δ\*<x\*>* ⊢ expr ↓ v\*<x\*>
.SEME

This produces a frame with named attributes from strings or integers. Since frames cannot have duplicate keys, any duplicate keys produce an error. Similarly, since not all strings are valid keys, any string which is not a valid key is an error.

.SH FRICASSÉE GROUP COLLECTOR (FK)

.TP
Final collector
.SEM Γ; W ⊢ result:FR ↓ V
Γ; W ⊢ result ↓ V
.SEME

.TP
Transformed collector
.SEM Γ; W ⊢ transform:FT tail:FK ↓ V
Γ; W ⊢ transform ↓ X,

Γ; X ⊢ tail ↓ V
.SEME

.SS TIME PARTS (T)
.TP
Days (T\*<0\*>)
.SEM (\fB0\fR/[\fB1\fR-\fB9\fR][\fB0\fR-\fB9\fR]*)\fBd\fRt:T\*<1\*> ↓ v * 86400 + u :: Int
t ↓ u :: Int
.SEME

.TP
Days (T\*<1\*>)
.SEM (\fB0\fR/[\fB1\fR-\fB9\fR][\fB0\fR-\fB9\fR]*)\fBh\fRt:T\*<2\*> ↓ v * 3600 + u :: Int
t ↓ u :: Int
.SEME

.TP
Hours (T\*<2\*>)
.SEM (\fB0\fR/[\fB1\fR-\fB9\fR][\fB0\fR-\fB9\fR]*)\fBm\fRt:T\*<3\*> ↓ v * 60 + u :: Int
t ↓ u :: Int
.SEME

.SS LOOKUP SOURCES (LS)

.TP
Use current context as source
.SEM Γ ⊢ \fBHere\fR ↓ Γ
.SEME

.TP
Use frame's context as source
.SEM Γ ⊢ \fBIn\fR expr:E\*<+\*> ↓ Δ
Γ ⊢ expr ↓ < u; Δ; ... >
.SEME

.TP
Use frame as source
.SEM Γ ⊢ \fBWithin\fR expr:E\*<+\*> ↓ (f)
Γ ⊢ expr ↓ f :: Frame
.SEME

.SS LOOKUP NAMES (LN)

.TP
Dynamic
.SEM Γ ⊢ \fBFlatten(\fR expr:E\*<0\*> \fB)\fR ↓ name\*<1\*>, name\*<2\*>, ...
Γ ⊢ expr ↓ < u; Δ; n\*<1\*> ⊢ v\*<1\*>,  n\*<2\*> ⊢ v\*<2\*>, ...>,

name\*<i\*> = v\*<i\*> : v\*<i\*> :: Str ∧ IDENTIFIER(v\*<i\*>) ∨ name\*<i\*> = v\*<i\*> : v\*<i\*> :: Int
.SEME

.TP
Sames as definition
.SEM Γ ⊢ name:DI ↓ n
Γ ⊢ name ↓ n
.SEME

.SS CONTEXTUAL LOOKUP HANDLER
This defines the semantics of the contextual lookup handler. There are other lookup handlers, but their semantics are not defined as part of the Flabbergast language.

.SEM (t, s, ...) ⊢  CONTEXTUAL(name\<*1\*>, ...) ↓ v
CONTEXTUAL_INNER(t; name\*<1\*>, ...) ↓ v
.SEME

.SEM (t, s, ...) ⊢  CONTEXTUAL(name\<*1\*>, ...) ↓ v
(s, ...) ⊢ CONTEXTUAL(name\*<1\*>, ...) ↓ v
.SEME

.SEM CONTEXTUAL_INNER(t; name) ↓ v
t = < u; Γ; name → v >
.SEME

.SEM CONTEXTUAL_INNER(t; name\*<1\*>, name\*<2\*>, ...) ↓ v
t = < u; Γ; name → s :: Frame >,

CONTEXTUAL_INNER(s; name\*<2\*>, ...) ↓ v
.SEME

.SH EVALUATION SEMANTICS
In the semantics defined above, it is possible for a value to depend on its own value. Such situation are errors with one notable exception: the contextual lookup operator.

During contextual lookup, a list of candidate frames is whittled down to a list of frames containing a matching name. Since only the first name is selected, the values of the other frames are immaterial. It is therefore possible for one of these values to be circular, or an error, and the result still be correct.

.SH URI NAME-SPACES AND THE STANDARD LIBRARY
The URIs understood by the importer is implementation defined with one exception: the \fBlib:\fR schema holds the standard (installed) library. An implementation is free to fail to include this schema, but it may not be used with other semantics.

On UNIX, it is recommended that importing \fBlib:foo\fR will search for \fBfoo.o_0\fR in:
Any user-specified paths specified via the API or the command-line, as appropriate.
The directories specified in the \fBFLABBERGAST_PATH\fR environment variable.
The directories matching {$PREFIX,/usr,/usr/local}/share/flabbergast/lib where $PREFIX is the installation prefix.

.SH COLLATED NAMES FROM NUMBERS
Frame keys are strings or integers. The sort order for integers is well-defined. For strings, locale-dependent collation should be used. The sort of integers and strings together is implementation-defined.

.SH SEE ALSO
.BR flabbergast_sql (7),
.BR flabbergast_uri (7).
